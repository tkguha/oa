<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Open Access & Open Science — Interactive Mindmap</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
  :root{
    --bg:#f5f7fb;
    --header-bg:#0b63b6;
    --header-fg:#ffffff;
    --font:"Segoe UI",Roboto,Arial,sans-serif;
  }
  *{box-sizing:border-box;}
  html,body{
    margin:0;
    height:100%;
    font-family:var(--font);
    background:var(--bg);
  }
  header{
    background:var(--header-bg);
    color:var(--header-fg);
    padding:10px 18px;
    font-size:20px;
    font-weight:600;
    text-align:center;
    display:flex;
    align-items:center;
    justify-content:center;
    position:relative;
  }
  header .controls{
    position:absolute;
    left:16px;
    display:flex;
    gap:6px;
  }
  header button{
    border:1px solid #0b63b6;
    background:#ffffff;
    color:#0b63b6;
    font-size:12px;
    padding:5px 10px;
    border-radius:6px;
    cursor:pointer;
  }
  header button:hover{
    background:#e3f2fd;
  }
  #canvas{
    position:relative;
    height:calc(100vh - 48px);
    overflow:hidden;
  }
  #searchBox{
    position:absolute;
    top:12px;
    left:50%;
    transform:translateX(-50%);
    width:320px;
    padding:7px 10px;
    border-radius:8px;
    border:1px solid #cfd8e3;
    background:#ffffff;
    box-shadow:0 1px 4px rgba(0,0,0,0.15);
    font-size:14px;
    z-index:20;
  }
  #credits{
    position:absolute;
    right:16px;
    top:12px;
    max-width:260px;
    background:#ffffff;
    border-radius:8px;
    padding:8px 10px;
    box-shadow:0 2px 8px rgba(0,0,0,0.18);
    font-size:12px;
    line-height:1.4;
    z-index:21;
  }
  #credits b{display:block;margin-bottom:4px;}
  #tooltip{
    position:absolute;
    padding:6px 8px;
    background:rgba(0,0,0,0.86);
    color:#ffffff;
    font-size:12px;
    border-radius:6px;
    display:none;
    max-width:280px;
    pointer-events:none;
    z-index:40;
  }
  svg.main{
    width:100%;
    height:100%;
    display:block;
    cursor:grab;
  }
  svg.minimap{
    position:absolute;
    right:16px;
    bottom:16px;
    width:260px;
    height:180px;
    border:1px solid #cfd8e3;
    background:#ffffff;
    box-shadow:0 2px 6px rgba(0,0,0,0.12);
    z-index:10;
  }
  .node rect{
    rx:10; ry:10;
    stroke-width:1.8px;
    filter:drop-shadow(0 1px 2px rgba(0,0,0,0.18));
  }
  .node text.label{
    font-size:14px;
    fill:#102a43;
    pointer-events:none;
  }
  .node.linked text.label{
    fill:#0b63b6;
    text-decoration:underline;
  }
  .link{
    fill:none;
    stroke-width:2px;
    opacity:0.95;
  }
  .end-dot{
    fill:#d32f2f;
    stroke:#b00000;
    stroke-width:1.4px;
  }
  .highlight rect{
    stroke:#ffeb3b !important;
    stroke-width:4px !important;
  }
</style>
</head>
<body>
<header>
  <div class="controls">
    <button id="btnExpand">Expand All</button>
    <button id="btnCollapse">Collapse All</button>
    <button id="btnFit">Fit to Screen</button>
    <button id="btnExportSVG">Export SVG</button>
    <button id="btnExportPNG">Export PNG</button>
  </div>
  <span>Open Access &amp; Open Science — Interactive Mindmap</span>
</header>
<div id="canvas">
  <input id="searchBox" type="text" placeholder="Search node..." />
  <div id="credits">
    <b>Credits</b>
    Dr. Tamal Kumar Guha,<br/>
    Librarian, IIT Guwahati<br/><br/>
    Presented at a Workshop on 22nd Nov. 2025 at NEHU, DLISc<br/>
    <i>Workshop Title:</i> Research Support Services: Role of Libraries and Library Professionals in the Digital Landscape
  </div>
  <div id="tooltip"></div>
  <svg class="main">
    <g id="linksLayer"></g>
    <g id="nodesLayer"></g>
  </svg>
  <svg class="minimap">
    <g id="miniLinks"></g>
    <g id="miniNodes"></g>
  </svg>
</div>
<script>
const CSV_URL = "https://raw.githubusercontent.com/tkguha/oa/main/oaos.csv";

const VERT_SPACING = 50;
const DEPTH_SPACING = 160;
const MIN_SEP = 40;
const LEFT_COUNT = 2;

const BRANCH_COLORS = [
  "#1976d2",
  "#2e7d32",
  "#fb8c00",
  "#6a1b9a"
];
const ROOT_FILL = "#08306b";
const ROOT_STROKE = "#08306b";

const svg = d3.select("svg.main");
const linkG = d3.select("#linksLayer");
const nodeG = d3.select("#nodesLayer");
const miniSvg = d3.select("svg.minimap");
const miniLinks = d3.select("#miniLinks");
const miniNodes = d3.select("#miniNodes");
const tooltip = d3.select("#tooltip");
const searchBox = document.getElementById("searchBox");

const zoom = d3.zoom()
  .scaleExtent([0.25, 3])
  .on("zoom", (event) => {
    const t = event.transform;
    linkG.attr("transform", t);
    nodeG.attr("transform", t);
  });

svg.call(zoom);

function width(){ return svg.node().clientWidth; }
function height(){ return svg.node().clientHeight; }

d3.csv(CSV_URL).then(raw => {
  const rows = raw.map(r => ({
    id: (r.node_id || "").trim(),
    parentId: (r.parent_id || "").trim(),
    level: +r.level || 0,
    label: (r.topic || "").trim(),
    link: (r.links || "").trim()
  })).filter(r => r.id);

  const map = new Map();
  rows.forEach(r => map.set(r.id, Object.assign(r, {children: []})));

  let rootData = null;
  map.forEach(node => {
    if (!node.parentId) {
      rootData = node;
    } else if (map.has(node.parentId)) {
      map.get(node.parentId).children.push(node);
    }
  });

  if (!rootData) {
    alert("No root node found (row with empty parent_id).");
    return;
  }

  const root = d3.hierarchy(rootData, d =>
    d.children && d.children.length ? d.children : null
  );

  if (root.children) {
    root.children.forEach((c, i) => {
      const side = (i < LEFT_COUNT) ? -1 : 1;
      const branch = i % BRANCH_COLORS.length;
      assignBranchAndSide(c, branch, side);
    });
  }

  function assignBranchAndSide(node, branch, side){
    node.data.branch = branch;
    node.data.side = side;
    node.children && node.children.forEach(ch => assignBranchAndSide(ch, branch, side));
  }

  const treeLayout = d3.tree().nodeSize([VERT_SPACING, 100]);

  update(root);
  setTimeout(() => fitToScreen(), 600);

  // toolbar buttons
  document.getElementById("btnExpand").onclick = () => { expandAll(root); update(root); fitToScreen(); };
  document.getElementById("btnCollapse").onclick = () => { collapseAll(root); update(root); fitToScreen(); };
  document.getElementById("btnFit").onclick = () => fitToScreen();
  document.getElementById("btnExportSVG").onclick = exportSVG;
  document.getElementById("btnExportPNG").onclick = exportPNG;

  function expandAll(node){
    if (node._children) {
      node.children = node._children;
      node._children = null;
    }
    node.children && node.children.forEach(expandAll);
  }

  function collapseAll(node){
    if (node.children) {
      node.children.forEach(collapseAll);
      node._children = node.children;
      node.children = null;
    }
  }

  function colorFor(d){
    if (d.depth === 0) {
      return {fill:ROOT_FILL, stroke:ROOT_STROKE};
    }
    const idx = d.data.branch ?? 0;
    const base = BRANCH_COLORS[idx % BRANCH_COLORS.length];
    const t = Math.min(d.depth/4, 0.6);
    return {
      fill: d3.interpolateRgb(base, "#ffffff")(t),
      stroke: d3.color(base).darker(0.8).formatHex()
    };
  }

  function update(source){
    treeLayout(root);
    const nodes = root.descendants();
    const links = root.links();

    // balanced left/right layout
    nodes.forEach(d => {
      const side = d.data.side !== undefined
        ? d.data.side
        : (d.parent ? d.parent.data.side || 1 : 1);
      d.screenX = d.x;
      d.screenY = d.depth * DEPTH_SPACING * side;
    });

    // simple physics-like vertical anti-overlap
    const depthGroups = d3.group(nodes, d => d.depth);
    depthGroups.forEach(group => {
      group.sort((a,b) => a.screenX - b.screenX);
      for (let i=1;i<group.length;i++){
        const prev = group[i-1];
        const curr = group[i];
        if (curr.screenX - prev.screenX < MIN_SEP) {
          curr.screenX = prev.screenX + MIN_SEP;
        }
      }
    });

    // ---------- NODES ----------
    const nodeSel = nodeG.selectAll("g.node")
      .data(nodes, d => d.data.id);

    const nodeEnter = nodeSel.enter()
      .append("g")
      .attr("class","node")
      .attr("transform", `translate(${source.y0 || 0},${source.x0 || 0})`)
      .style("cursor","pointer")
      .on("click", (event, d) => {
        event.stopPropagation();
        if (d.children || d._children) {
          if (d.children) {
            d._children = d.children;
            d.children = null;
          } else {
            d.children = d._children;
            d._children = null;
          }
          update(d);
        }
        centerOn(d);   // click-to-center
      })
      .on("dblclick", (event, d) => {
        event.stopPropagation();
        if (d.data.link) {
          window.open(d.data.link, "_blank", "noopener");
        }
      });

    // label text only (rect added after measuring)
    nodeEnter.append("text")
      .attr("class","label")
      .attr("text-anchor","start")
      .text(d => d.data.label || d.data.id);

    // dynamic node boxes
    nodeEnter.each(function(d){
      const g = d3.select(this);
      const text = g.select("text.label");
      const bbox = text.node().getBBox();
      const padX = 12, padY = 6;
      const width = bbox.width + padX*2;
      const height = bbox.height + padY*2;
      const {fill,stroke} = colorFor(d);

      g.insert("rect","text")
        .attr("x", -width/2)
        .attr("y", -height/2)
        .attr("width", width)
        .attr("height", height)
        .style("fill", fill)
        .style("stroke", stroke);

      text
        .attr("x", -bbox.width/2)
        .attr("y", bbox.height/4);

      if (d.depth === 0) {
        text.style("fill","#ffffff").style("font-weight","600");
      } else if (d.data.link) {
        g.classed("linked", true);
      }
    });

    const nodeMerge = nodeEnter.merge(nodeSel);

    nodeMerge.transition().duration(250)
      .attr("transform", d => `translate(${d.screenY},${d.screenX})`);

    // end-of-branch red dots
    nodeMerge.each(function(d){
      const g = d3.select(this);
      g.select("circle.end-dot").remove();
      if (!d.children && !d._children) {
        const rect = g.select("rect").node().getBBox();
        const side = d.data.side ?? (d.parent ? d.parent.data.side || 1 : 1);
        const cx = side >= 0 ? rect.x + rect.width + 10 : rect.x - 10;
        g.append("circle")
          .attr("class","end-dot")
          .attr("r",5)
          .attr("cx",cx)
          .attr("cy",0);
      }
    });

    nodeSel.exit()
      .transition().duration(200)
      .style("opacity",0)
      .remove();

    // ---------- LINKS ----------
    const linkSel = linkG.selectAll("path.link")
      .data(links, d => d.target.data.id);

    const linkEnter = linkSel.enter()
      .append("path")
      .attr("class","link")
      .attr("d", d => linkPath(source, source));

    linkEnter.merge(linkSel)
      .style("stroke", d => colorFor(d.target).stroke)
      .transition().duration(250)
      .attr("d", d => linkPath(d.source, d.target));

    linkSel.exit()
      .transition().duration(200)
      .style("opacity",0)
      .remove();

    // save previous positions
    nodes.forEach(d => { d.x0 = d.screenX; d.y0 = d.screenY; });

    drawMinimap(nodes, links);
  }

  function linkPath(s,d){
    const sx = s.screenY ?? s.y0;
    const sy = s.screenX ?? s.x0;
    const tx = d.screenY ?? d.y0;
    const ty = d.screenX ?? d.x0;
    const dx = (tx - sx)*0.55;
    return `M${sx},${sy} C${sx+dx},${sy} ${tx-dx},${ty} ${tx},${ty}`;
  }

  function getNodesBBox(){
    try{
      return nodeG.node().getBBox();
    }catch(e){
      return {x:0,y:0,width:1,height:1};
    }
  }
  function fitToScreen(){
    const box = getNodesBBox();
    const w = width(), h = height();
    const margin = 80;
    const scale = Math.min(
      (w - margin)/box.width,
      (h - margin)/box.height
    );
    const s = Math.max(0.25, Math.min(scale, 1.8));
    const tx = (w - box.width*s)/2 - box.x*s;
    const ty = (h - box.height*s)/2 - box.y*s;
    svg.transition().duration(500)
      .call(zoom.transform, d3.zoomIdentity.translate(tx,ty).scale(s));
  }

  function centerOn(d){
    const w = width(), h = height();
    const current = d3.zoomTransform(svg.node());
    const k = current.k;
    const x = d.screenY;
    const y = d.screenX;
    const tx = w/2 - x*k;
    const ty = h/2 - y*k;
    svg.transition().duration(400)
      .call(zoom.transform, d3.zoomIdentity.translate(tx,ty).scale(k));
  }

  // -------- minimap --------
  function drawMinimap(nodes, links){
    const box = getNodesBBox();
    const mw = miniSvg.node().clientWidth;
    const mh = miniSvg.node().clientHeight;
    const scale = Math.min(mw/box.width, mh/box.height)*0.85;
    const tx = (mw - box.width*scale)/2 - box.x*scale;
    const ty = (mh - box.height*scale)/2 - box.y*scale;

    const transform = d => [
      d.screenY*scale + tx,
      d.screenX*scale + ty
    ];

    const mLinks = miniLinks.selectAll("path").data(links, d => d.target.data.id);
    mLinks.enter().append("path").merge(mLinks)
      .attr("d", d => {
        const s = transform(d.source);
        const t = transform(d.target);
        return `M${s[0]},${s[1]} L${t[0]},${t[1]}`;
      })
      .attr("stroke","#cfd8e3")
      .attr("stroke-width",1)
      .attr("fill","none");
    mLinks.exit().remove();

    const mNodes = miniNodes.selectAll("circle").data(nodes, d => d.data.id);
    mNodes.enter().append("circle").merge(mNodes)
      .attr("r",2)
      .attr("cx", d => transform(d)[0])
      .attr("cy", d => transform(d)[1])
      .attr("fill","#546e7a");
    mNodes.exit().remove();
  }

  // -------- search --------
  searchBox.addEventListener("input", () => {
    const q = searchBox.value.trim().toLowerCase();
    const nodesSel = nodeG.selectAll("g.node");
    nodesSel.classed("highlight", false);
    if (!q) return;
    const matches = nodesSel.filter(d =>
      (d.data.label || "").toLowerCase().includes(q)
    );
    matches.classed("highlight", true);
    const first = matches.datum();
    if (first) centerOn(first);
  });

  // -------- export SVG --------
  function exportSVG(){
    const clone = svg.node().cloneNode(true);
    clone.removeAttribute("style");
    const outer = document.createElementNS("http://www.w3.org/2000/svg","svg");
    outer.setAttribute("xmlns","http://www.w3.org/2000/svg");
    outer.setAttribute("width", width());
    outer.setAttribute("height", height());
    outer.setAttribute("viewBox", `0 0 ${width()} ${height()}`);
    outer.appendChild(clone);
    const serializer = new XMLSerializer();
    const source = serializer.serializeToString(outer);
    const blob = new Blob([source],{type:"image/svg+xml;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "open_access_open_science_mindmap.svg";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  // -------- export PNG --------
  function exportPNG(){
    const serializer = new XMLSerializer();
    const clone = svg.node().cloneNode(true);
    const outer = document.createElementNS("http://www.w3.org/2000/svg","svg");
    outer.setAttribute("xmlns","http://www.w3.org/2000/svg");
    outer.setAttribute("width", width());
    outer.setAttribute("height", height());
    outer.setAttribute("viewBox", `0 0 ${width()} ${height()}`);
    outer.appendChild(clone);
    const source = serializer.serializeToString(outer);
    const svgBlob = new Blob([source],{type:"image/svg+xml;charset=utf-8"});
    const url = URL.createObjectURL(svgBlob);
    const img = new Image();
    img.onload = function(){
      const canvas = document.createElement("canvas");
      canvas.width = width();
      canvas.height = height();
      const ctx = canvas.getContext("2d");
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.drawImage(img,0,0);
      URL.revokeObjectURL(url);
      canvas.toBlob(blob => {
        const url2 = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url2;
        a.download = "open_access_open_science_mindmap.png";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url2);
      });
    };
    img.src = url;
  }

}).catch(err => {
  console.error("Error loading CSV:",err);
  alert("Failed to load CSV. See console for details.");
});
</script>
</body>
</html>
