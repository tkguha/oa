<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Open Access & Open Science</title>

<script src="https://d3js.org/d3.v7.min.js"></script>

<style>
  body { margin:0; font-family:Segoe UI,Arial; background:#f4f6fa; }
  header { background:#0b63b6; color:white; padding:15px; text-align:center; font-size:22px; font-weight:600; }
  svg { width:100vw; height:100vh; cursor:grab; }

  .node rect { rx:10; ry:10; stroke-width:2; filter:drop-shadow(0 1px 2px rgba(0,0,0,0.2)); }
  .node text { font-size:14px; pointer-events:none; }

  .link { fill:none; stroke:#bfbfbf; stroke-width:2; }

  .tooltip {
    position:absolute; background:rgba(0,0,0,0.8); color:#fff;
    padding:8px 10px; border-radius:6px; font-size:13px;
    display:none; z-index:10;
  }

  #legend {
    position:absolute; left:15px; top:80px; z-index:20;
    background:white; padding:10px; border-radius:8px;
    font-size:13px; box-shadow:0 2px 6px rgba(0,0,0,0.1);
  }

  .end-dot { fill:#d32f2f; stroke:#b00000; stroke-width:1.5; }
</style>
</head>

<body>
<header>Open Access & Open Science</header>

<div id="legend">
Click → open URL (if present)<br>
Double-click → expand/collapse<br>
Hover → details
</div>

<div id="tooltip" class="tooltip"></div>
<svg></svg>

<script>
// YOUR GOOGLE SHEET CSV
const csvUrl =
  "https://docs.google.com/spreadsheets/d/e/2PACX-1vQtE2jkMXdOlWaUrLFglbi5PH7hwvN0H7wV-A3EEZrQjZFLhI_d0AA1_nN-I9YrXXlmwzgolneWo8Uk/pub?gid=0&single=true&output=csv";

// ROOT FIX — CENTRAL CONCEPT ID
const ROOT_ID = "1";

const svg = d3.select("svg");
const g = svg.append("g");

const tooltip = d3.select("#tooltip");

const zoom = d3.zoom().scaleExtent([0.25,3]).on("zoom", e => g.attr("transform", e.transform));
svg.call(zoom);

const tree = d3.tree().nodeSize([70,200]);

// Colors by depth
const fills = ["#08306b","#dbeefe","#fff3e0","#e8f5e9","#f3e8ff","#fff5f5"];
const strokes = ["#08306b","#2b6cb0","#fb8c00","#2e7d32","#6a1b9a","#c62828"];

d3.csv(csvUrl).then(raw => {

  // Normalize rows
  raw = raw.map(r => ({
    ID: r.ID.trim(),
    Name: (r.Name || r.NAMES || "").trim(),
    ParentID: (r.ParentID || "").trim(),
    PhotoURL: (r.PhotoURL || "").trim(),
    Details: (r.Details || "").trim()
  }));

  // === BUILD TREE STRUCTURE ===
  const map = new Map(raw.map(r => [r.ID, {...r, children:[]}]));

  raw.forEach(r => {
    if (r.ParentID && map.has(r.ParentID)) {
      map.get(r.ParentID).children.push(map.get(r.ID));
    }
  });

  // FORCE ROOT = ID 1
  const rootNode = map.get(ROOT_ID);
  const root = d3.hierarchy(rootNode);

  root.x0 = 0;
  root.y0 = 0;

  // collapse initially
  root.children?.forEach(collapse);

  // assign left/right
  if (root.children) {
    root.children.forEach((c,i)=>{
      c.data.side = (i<2 ? -1 : 1);
      assignSide(c, c.data.side);
    });
  }

  update(root);

  svg.call(
    zoom.transform,
    d3.zoomIdentity.translate(window.innerWidth/2,150).scale(0.9)
  );

  // FUNCTIONS
  function assignSide(node,side){
    node.data.side = side;
    node.children?.forEach(ch => assignSide(ch,side));
    node._children?.forEach(ch => assignSide(ch,side));
  }

  function collapse(n){
    if(n.children){
      n._children = n.children;
      n._children.forEach(collapse);
      n.children = null;
    }
  }

  function update(source){
    const layout = tree(root);
    const nodes = layout.descendants();
    const links = layout.links();

    nodes.forEach(d => {
      d.y = d.depth * 200 * (d.data.side || 1);
    });

    // NODES
    const node = g.selectAll("g.node").data(nodes, d => d.data.ID);

    const enter = node.enter().append("g")
      .attr("class","node")
      .attr("transform",`translate(${source.y0},${source.x0})`)
      .on("click",(e,d)=>{
        if (d.data.PhotoURL) window.open(d.data.PhotoURL,"_blank");
      })
      .on("dblclick",(e,d)=>{
        e.stopPropagation();
        if(d.children){ d._children=d.children; d.children=null; }
        else { d.children=d._children; d._children=null; }
        update(d);
      })
      .on("mouseover",(e,d)=>{
        if(d.data.Details){
          tooltip.style("display","block").html(d.data.Details);
        }
      })
      .on("mousemove",(e)=>{
        tooltip.style("left",(e.pageX+12)+"px")
               .style("top",(e.pageY+12)+"px");
      })
      .on("mouseout",()=> tooltip.style("display","none"));

    enter.append("text")
      .attr("dy","0.35em")
      .attr("text-anchor","middle")
      .text(d => d.data.Name);

    enter.each(function(d){
      const t = d3.select(this).select("text").node();
      const bb = t.getBBox();
      const pw=14, ph=8;
      const W = bb.width + pw*2;
      const H = bb.height + ph*2;
      const depth = Math.min(d.depth, fills.length-1);

      d3.select(this).insert("rect","text")
        .attr("x",-W/2)
        .attr("y",-H/2)
        .attr("width",W)
        .attr("height",H)
        .style("fill", fills[depth])
        .style("stroke", strokes[depth]);

      if(d.depth===0){
        d3.select(this).select("rect")
          .style("fill",fills[0])
          .style("stroke",strokes[0]);
        d3.select(this).select("text")
          .style("fill","white")
          .style("font-weight","600");
      }
    });

    // red end dot
    enter.append("circle")
      .attr("class","end-dot")
      .attr("r",5)
      .attr("cy",0)
      .attr("cx",d=>{
        const rect = d3.select(this).select("rect").node();
        return (d.data.side>=0? 80 : -80);
      })
      .style("opacity",d => (!d.children && !d._children)?1:0);

    const merged = enter.merge(node);

    merged.transition().duration(500)
      .attr("transform", d => `translate(${d.y},${d.x})`);

    merged.select("circle.end-dot")
      .style("opacity",d => (!d.children && !d._children)?1:0);

    node.exit().remove();

    // LINKS
    const link = g.selectAll("path.link").data(links, d=>d.target.data.ID);

    link.enter().insert("path","g")
      .attr("class","link")
      .attr("d",_=>diag(source,source))
      .merge(link)
      .transition().duration(500)
      .attr("d",d=>diag(d.source,d.target));

    link.exit().remove();

    nodes.forEach(d=>{ d.x0=d.x; d.y0=d.y; });
  }

  function diag(s,d){
    return `M ${s.y} ${s.x}
            C ${(s.y+d.y)/2} ${s.x},
              ${(s.y+d.y)/2} ${d.x},
              ${d.y} ${d.x}`;
  }

});
</script>

</body>
</html>
