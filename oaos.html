<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Open Access & Open Science — Interactive Mindmap</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
  :root {
    --bg: #f4f6fb;
    --header-bg: #0b63b6;
    --header-fg: #ffffff;
    --node-bg: #ffffff;
    --node-stroke: #607d8b;
    --text: #102a43;
  }

  html, body {
    margin: 0;
    height: 100%;
    font-family: "Segoe UI", Roboto, Arial, sans-serif;
    background: var(--bg);
  }

  body {
    display: flex;
    flex-direction: column;
  }

  header {
    background: var(--header-bg);
    color: var(--header-fg);
    padding: 10px 16px;
    display: flex;
    align-items: center;
    gap: 16px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.18);
    z-index: 10;
  }

  header h1 {
    margin: 0;
    font-size: 18px;
    font-weight: 600;
    flex: 1;
    text-align: center;
  }

  .toolbar {
    display: flex;
    gap: 6px;
  }

  .toolbar button {
    border: none;
    border-radius: 999px;
    padding: 6px 10px;
    font-size: 12px;
    cursor: pointer;
    background: #e3f2fd;
    color: #0b63b6;
    font-weight: 500;
    box-shadow: 0 1px 2px rgba(0,0,0,0.18);
  }

  .toolbar button:hover {
    background: #bbdefb;
  }

  #canvas {
    flex: 1;
    position: relative;
    overflow: hidden;
  }

  svg#mainSvg {
    width: 100%;
    height: 100%;
    display: block;
    cursor: grab;
  }

  #searchBox {
    position: absolute;
    left: 50%;
    top: 12px;
    transform: translateX(-50%);
    width: 320px;
    padding: 7px 10px;
    border-radius: 999px;
    border: 1px solid #cbd5e1;
    font-size: 13px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.12);
    z-index: 20;
  }

  #credits {
    position: absolute;
    right: 12px;
    top: 12px;
    max-width: 260px;
    background: #ffffff;
    border-radius: 10px;
    padding: 8px 10px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    font-size: 12px;
    line-height: 1.4;
    z-index: 20;
  }
  #credits b { display:block; margin-bottom:4px; }

  #tooltip {
    position: absolute;
    padding: 6px 8px;
    font-size: 12px;
    max-width: 260px;
    border-radius: 6px;
    background: rgba(0,0,0,0.85);
    color: #fff;
    pointer-events: none;
    display: none;
    z-index: 30;
  }

  .node rect {
    rx: 10;
    ry: 10;
    fill: var(--node-bg);
    stroke: var(--node-stroke);
    stroke-width: 1.6px;
    filter: drop-shadow(0 1px 2px rgba(0,0,0,0.20));
  }

  .node text {
    font-size: 13px;
    fill: var(--text);
    pointer-events: none;
  }

  .link {
    fill: none;
    stroke-width: 2px;
    opacity: 0.9;
  }

  .linked text {
    fill: #0b63b6;
    text-decoration: underline;
  }

  .end-dot {
    fill: #d32f2f;
    stroke: #b00000;
    stroke-width: 1.4;
  }

  .highlight rect {
    stroke: #ffeb3b !important;
    stroke-width: 4px !important;
  }

  /* mini-map */
  #minimapContainer {
    position: absolute;
    right: 14px;
    bottom: 14px;
    width: 220px;
    height: 150px;
    background:#ffffff;
    border-radius: 6px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    padding: 4px;
    z-index: 15;
  }
  #minimap {
    width: 100%;
    height: 100%;
  }
  #minimap .node rect {
    filter:none;
    stroke-width:0.8px;
  }
  #minimapViewport {
    fill:none;
    stroke:#ff5722;
    stroke-width:1.2px;
  }
</style>
</head>

<body>
<header>
  <div class="toolbar">
    <button id="btnExpand">Expand All</button>
    <button id="btnCollapse">Collapse All</button>
    <button id="btnFit">Fit to Screen</button>
    <button id="btnExportSvg">Export SVG</button>
    <button id="btnExportPng">Export PNG</button>
  </div>
  <h1>Open Access & Open Science — Interactive Mindmap</h1>
  <div style="width:220px"></div>
</header>

<div id="canvas">
  <input id="searchBox" type="text" placeholder="Search node...">
  <div id="credits">
    <b>Credits</b>
    Dr. Tamal Kumar Guha,<br/>
    Librarian, IIT Guwahati<br/><br/>
    Presented at a Workshop on 22nd Nov. 2025 at NEHU, DLISc<br/>
    <i>Workshop Title:</i> Research Support Services: Role of Libraries and
    Library Professionals in the Digital Landscape
  </div>
  <div id="tooltip"></div>

  <svg id="mainSvg">
    <g id="links-layer"></g>
    <g id="nodes-layer"></g>
  </svg>

  <div id="minimapContainer">
    <svg id="minimap">
      <g id="mini-links"></g>
      <g id="mini-nodes"></g>
      <rect id="minimapViewport"></rect>
    </svg>
  </div>
</div>

<script>
const CSV_URL = "https://raw.githubusercontent.com/tkguha/oa/main/oaos.csv";

// Branch colors for first 4 main children
const BRANCH_COLORS = [
  "#1976d2", // 1
  "#2e7d32", // 2
  "#fb8c00", // 3
  "#6a1b9a"  // 4
];

const VERT_SPACING = 55;
const HORIZ_SPACING = 150;
const MIN_SEP = 40;

const svg       = d3.select("#mainSvg");
const linkLayer = d3.select("#links-layer");
const nodeLayer = d3.select("#nodes-layer");
const miniSvg   = d3.select("#minimap");
const miniLinks = d3.select("#mini-links");
const miniNodes = d3.select("#mini-nodes");
const miniViewport = d3.select("#minimapViewport");
const tooltip   = d3.select("#tooltip");
const searchBox = document.getElementById("searchBox");

const zoom = d3.zoom()
  .scaleExtent([0.25, 3])
  .on("zoom", (event) => {
    const t = event.transform;
    linkLayer.attr("transform", t);
    nodeLayer.attr("transform", t);
    updateMiniViewport(t);
  });

svg.call(zoom);

const treeLayout = d3.tree().nodeSize([VERT_SPACING, HORIZ_SPACING]);

// ---- helpers to get dimensions ----
const getWidth  = () => svg.node().clientWidth  || svg.node().viewBox.baseVal.width;
const getHeight = () => svg.node().clientHeight || svg.node().viewBox.baseVal.height;

// ---- load CSV ----
d3.csv("https://raw.githubusercontent.com/tkguha/oa/main/oaos.csv").then(rows => {
  // normalise
  const prepared = rows.map(r => ({
    id:       (r.node_id || "").trim(),
    parentId: (r.parent_id || "").trim(),
    level:    +r.level || 0,
    topic:    (r.topic || "").trim(),
    link:     (r.links || "").trim()
  })).filter(r => r.id);

  const byId = new Map();
  prepared.forEach(r => byId.set(r.id, {...r, children: []}));

  let rootData = null;
  byId.forEach(n => {
    if (!n.parentId) rootData = n;
  });
  if (!rootData) {
    alert("Could not find root node (row with empty parent_id).");
    return;
  }

  byId.forEach(n => {
    if (n.parentId) {
      const p = byId.get(n.parentId);
      if (p) p.children.push(n);
    }
  });

  const root = d3.hierarchy(rootData, d => d.children && d.children.length ? d.children : null);

  // assign branch + side for main children
  if (root.children) {
    const mid = Math.ceil(root.children.length / 2);
    root.children.forEach((c, i) => {
      const side   = (i < mid) ? -1 : 1; // left / right
      const branch = i % BRANCH_COLORS.length;
      assignBranch(c, branch, side);
    });
  }

  function assignBranch(node, branchIndex, side) {
    node.data.branch = branchIndex;
    node.data.side   = side;
    node.children?.forEach(ch => assignBranch(ch, branchIndex, side));
  }

  // collapse beyond depth 2 (show first 2 levels)
  root.x0 = 0; root.y0 = 0;
  root.descendants().forEach(d => {
    if (d.depth >= 3 && d.children) {
      d._children = d.children;
      d.children = null;
    }
  });

  // auto-number sequentially
  root.descendants().forEach((d, i) => d.data.seq = i + 1);

  update(root);
  setTimeout(() => fitToScreen(root), 400);

  // ------------- MAIN UPDATE -------------
  function update(source) {
    treeLayout(root);
    const nodes = root.descendants();
    const links = root.links();

    // set side-based coordinates and anti-overlap
    nodes.forEach(d => {
      const side = d.data.side ?? (d.parent ? d.parent.data.side || 1 : 1);
      d.yPos = d.depth * HORIZ_SPACING * side;
      d.xPos = d.x;
    });

    const groupByDepth = d3.group(nodes, d => d.depth);
    groupByDepth.forEach(arr => {
      arr.sort((a,b) => a.xPos - b.xPos);
      for (let i = 1; i < arr.length; i++) {
        const prev = arr[i-1];
        const cur  = arr[i];
        if (cur.xPos - prev.xPos < MIN_SEP) {
          cur.xPos = prev.xPos + MIN_SEP;
        }
      }
    });

    // ---- draw nodes ----
    const nodeSel = nodeLayer.selectAll("g.node")
      .data(nodes, d => d.data.id);

    const nodeEnter = nodeSel.enter()
      .append("g")
      .attr("class","node")
      .attr("transform", d => `translate(${source.y0 || 0},${source.x0 || 0})`)
      .style("cursor","pointer")
      .on("click", (event, d) => {
        // center on node
        centerOnNode(d);
        // follow link if present (ctrl+click: open, click: just center)
        if (d.data.link && !event.ctrlKey && !event.metaKey) {
          // only center; link on shift+click maybe later
        } else if (d.data.link && (event.ctrlKey || event.metaKey)) {
          window.open(d.data.link, "_blank","noopener");
        }
      })
      .on("dblclick", (event, d) => {
        event.stopPropagation();
        toggleNode(d);
      })
      .on("mouseover", (event, d) => {
        if (!d.data.link) return;
        tooltip.style("display","block")
               .html(d.data.link)
               .style("left", (event.pageX + 10) + "px")
               .style("top",  (event.pageY + 10) + "px");
      })
      .on("mouseout", () => tooltip.style("display","none"));

    // create text first (for bbox)
    nodeEnter.append("text")
      .attr("class","label")
      .attr("text-anchor","middle")
      .attr("dy","0.32em")
      .text(d => `${d.data.seq}. ${d.data.topic}`);

    nodeEnter.each(function(d){
      const g = d3.select(this);
      const tNode = g.select("text").node();
      const bb = tNode.getBBox();
      const padX = 12, padY = 6;
      const w = bb.width + padX*2;
      const h = bb.height + padY*2;

      const colors = colorFor(d);

      g.insert("rect","text")
        .attr("x", -w/2)
        .attr("y", -h/2)
        .attr("width", w)
        .attr("height", h)
        .style("fill", colors.fill)
        .style("stroke", colors.stroke);

      if (d.data.link) {
        g.classed("linked", true);
      }

      if (!d.children && !d._children) {
        const side = d.data.side ?? (d.parent ? d.parent.data.side || 1 : 1);
        const dotX = side >= 0 ? (w/2 + 8) : -(w/2 + 8);
        g.append("circle")
          .attr("class","end-dot")
          .attr("r",4.5)
          .attr("cx", dotX)
          .attr("cy",0);
      }
    });

    const nodeMerge = nodeEnter.merge(nodeSel);

    nodeMerge.transition().duration(250)
      .attr("transform", d => `translate(${d.yPos},${d.xPos})`);

    nodeSel.exit()
      .transition().duration(200)
      .style("opacity",0)
      .remove();

    // ---- draw links ----
    const linkSel = linkLayer.selectAll("path.link")
      .data(links, d => d.target.data.id);

    const linkEnter = linkSel.enter()
      .append("path")
      .attr("class","link")
      .style("stroke", d => colorFor(d.target).stroke)
      .attr("d", d => curvedPath(source, source));

    linkEnter.merge(linkSel)
      .transition().duration(250)
      .style("stroke", d => colorFor(d.target).stroke)
      .attr("d", d => curvedPath(d.source, d.target));

    linkSel.exit()
      .transition().duration(200)
      .style("opacity",0)
      .remove();

    nodes.forEach(d => { d.x0 = d.xPos; d.y0 = d.yPos; });

    drawMinimap(nodes, links);
  }

  // -------- helpers --------
  function toggleNode(d){
    if (d.children) {
      d._children = d.children;
      d.children = null;
    } else {
      d.children = d._children;
      d._children = null;
    }
    update(d);
  }

  function colorFor(d){
    if (d.depth === 0) {
      return {fill:"#08306b", stroke:"#08306b"};
    }
    const idx = d.data.branch ?? 0;
    const base = d3.color(BRANCH_COLORS[idx % BRANCH_COLORS.length]);
    const t = Math.min(d.depth/4, 0.6);
    return {
      fill: d3.interpolateRgb(base, "#ffffff")(t),
      stroke: base.darker(0.7)
    };
  }

  function curvedPath(s, t){
    const x1 = s.xPos ?? s.x0;
    const y1 = s.yPos ?? s.y0;
    const x2 = t.xPos ?? t.y0;
    const y2 = t.yPos ?? t.y0;
    const k = 0.55;
    const cx1 = y1 + (y2 - y1) * k;
    const cx2 = y2 - (y2 - y1) * k;
    return `M${y1},${x1} C${cx1},${x1} ${cx2},${x2} ${y2},${x2}`;
  }

  function fitToScreen(source){
    try{
      const box = nodeLayer.node().getBBox();
      const w = getWidth();
      const h = getHeight();
      const margin = 60;

      const scale = Math.min(
        (w - margin)/box.width,
        (h - margin)/box.height
      );

      const s = Math.max(0.3, Math.min(scale, 1.5));
      const tx = (w - box.width*s)/2 - box.x*s;
      const ty = (h - box.height*s)/2 - box.y*s;

      svg.transition().duration(450)
        .call(zoom.transform, d3.zoomIdentity.translate(tx,ty).scale(s));
    } catch(err) {
      console.warn("fitToScreen error:", err);
    }
  }

  function centerOnNode(d){
    const w = getWidth(), h = getHeight();
    const scale = d3.zoomTransform(svg.node()).k;
    const targetScale = Math.min(1.8, Math.max(0.8, scale * 1.1));
    const x = d.yPos, y = d.xPos;

    const tx = w/2 - x * targetScale;
    const ty = h/2 - y * targetScale;

    svg.transition().duration(400)
       .call(zoom.transform, d3.zoomIdentity.translate(tx,ty).scale(targetScale));
  }

  // minimap
  function drawMinimap(nodes, links){
    const miniW = +miniSvg.attr("width")  || miniSvg.node().clientWidth;
    const miniH = +miniSvg.attr("height") || miniSvg.node().clientHeight;

    const box = nodeLayer.node().getBBox();
    const sx = miniW / box.width;
    const sy = miniH / box.height;
    const s  = Math.min(sx, sy);

    const ox = -box.x * s;
    const oy = -box.y * s;

    const nData = nodes.map(d => ({
      id:d.data.id,
      x:(d.yPos)*s + ox,
      y:(d.xPos)*s + oy,
      depth:d.depth,
      branch:d.data.branch
    }));

    const lData = links.map(l => ({
      sx:(l.source.yPos)*s + ox,
      sy:(l.source.xPos)*s + oy,
      tx:(l.target.yPos)*s + ox,
      ty:(l.target.xPos)*s + oy,
      branch:l.target.data.branch
    }));

    const miniLinkSel = miniLinks.selectAll("line")
      .data(lData, d => d.sx + "-" + d.tx + "-" + d.ty);

    miniLinkSel.enter().append("line")
      .merge(miniLinkSel)
      .attr("x1",d=>d.sx).attr("y1",d=>d.sy)
      .attr("x2",d=>d.tx).attr("y2",d=>d.ty)
      .attr("stroke",d=>BRANCH_COLORS[(d.branch||0)%BRANCH_COLORS.length])
      .attr("stroke-width",0.8);

    miniLinkSel.exit().remove();

    const miniNodeSel = miniNodes.selectAll("circle")
      .data(nData, d=>d.id);

    miniNodeSel.enter().append("circle")
      .merge(miniNodeSel)
      .attr("cx",d=>d.x).attr("cy",d=>d.y)
      .attr("r",d=>d.depth===0?3:1.6)
      .attr("fill",d=>BRANCH_COLORS[(d.branch||0)%BRANCH_COLORS.length]);

    miniNodeSel.exit().remove();

    // store scale/offset for viewport
    miniSvg.node().__bboxScale = {s,ox,oy,boxW:box.width,boxH:box.height};
    updateMiniViewport(d3.zoomTransform(svg.node()));
  }

  function updateMiniViewport(t){
    const info = miniSvg.node().__bboxScale;
    if (!info) return;
    const {s,ox,oy,boxW,boxH} = info;
    const inv = t.invert([0,0]);
    const invBR = t.invert([getWidth(), getHeight()]);

    const vx1 = inv[0]*s + ox;
    const vy1 = inv[1]*s + oy;
    const vx2 = invBR[0]*s + ox;
    const vy2 = invBR[1]*s + oy;

    miniViewport
      .attr("x",vx1).attr("y",vy1)
      .attr("width",vx2-vx1).attr("height",vy2-vy1);
  }

  // -------- search --------
  searchBox.addEventListener("input", () => {
    const q = searchBox.value.trim().toLowerCase();
    const nodes = nodeLayer.selectAll("g.node");
    nodes.classed("highlight",false);
    if (!q) return;

    const matches = nodes.filter(d =>
      (d.data.topic || "").toLowerCase().includes(q)
    );
    matches.classed("highlight",true);

    const first = matches.datum();
    if (first) centerOnNode(first);
  });

  // -------- buttons --------
  document.getElementById("btnExpand").onclick = () => {
    root.descendants().forEach(d => {
      if (d._children) {
        d.children = d._children;
        d._children = null;
      }
    });
    update(root);
    setTimeout(()=>fitToScreen(root),300);
  };

  document.getElementById("btnCollapse").onclick = () => {
    root.descendants().forEach(d => {
      if (d.depth >= 1 && d.children) {
        d._children = d.children;
        d.children = null;
      }
    });
    update(root);
    setTimeout(()=>fitToScreen(root),300);
  };

  document.getElementById("btnFit").onclick = () => fitToScreen(root);

  document.getElementById("btnExportSvg").onclick = () => {
    const serializer = new XMLSerializer();
    const svgNode = document.getElementById("mainSvg");
    const clone = svgNode.cloneNode(true);
    clone.removeAttribute("style");
    const svgBlob = new Blob(
      ['<?xml version="1.0" encoding="UTF-8"?>\n', serializer.serializeToString(clone)],
      {type: "image/svg+xml;charset=utf-8"}
    );
    const url = URL.createObjectURL(svgBlob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "open-access-open-science-mindmap.svg";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  document.getElementById("btnExportPng").onclick = () => {
    const serializer = new XMLSerializer();
    const svgNode = document.getElementById("mainSvg");
    const clone = svgNode.cloneNode(true);
    clone.removeAttribute("style");
    const svgStr = serializer.serializeToString(clone);
    const canvas = document.createElement("canvas");
    const w = getWidth(), h = getHeight();
    canvas.width = w * 2;
    canvas.height = h * 2;
    const ctx = canvas.getContext("2d");
    const img = new Image();
    const svgBlob = new Blob([svgStr], {type:"image/svg+xml;charset=utf-8"});
    const url = URL.createObjectURL(svgBlob);
    img.onload = () => {
      ctx.setTransform(2,0,0,2,0,0);
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0,0,w,h);
      ctx.drawImage(img,0,0);
      URL.revokeObjectURL(url);
      const pngUrl = canvas.toDataURL("image/png");
      const a = document.createElement("a");
      a.href = pngUrl;
      a.download = "open-access-open-science-mindmap.png";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    };
    img.src = url;
  };

}); // end csv then
</script>
</body>
</html>
