<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Open Access & Open Science — Interactive Mindmap</title>
<script src="https://d3js.org/d3.v7.min.js"></script>

<style>
/* ============================
   GLOBAL THEME
   ============================ */
:root {
    --root-color: #0b63b6;        /* Royal blue root node */
    --bg: #f5f7fb;
    --font: "Segoe UI", Roboto, Arial, sans-serif;

    /* Pastel Cool Blues (4 branch families) */
    --branch1: #dbeafe;  /* soft blue */
    --branch1-stroke: #1e40af;

    --branch2: #e0f2fe;  /* soft cyan */
    --branch2-stroke: #0369a1;

    --branch3: #e0e7ff;  /* soft indigo */
    --branch3-stroke: #4338ca;

    --branch4: #f0f9ff;  /* pale light cyan */
    --branch4-stroke: #0e7490;
}

/* ============================
   PAGE BASE
   ============================ */
html, body {
    margin: 0;
    height: 100%;
    background: var(--bg);
    font-family: var(--font);
    overflow: hidden;
}

header {
    background: var(--root-color);
    color: white;
    padding: 14px 18px;
    font-size: 22px;
    font-weight: 600;
    text-align: center;
}

/* ============================
   CONTROL BUTTONS
   ============================ */
#controls {
    position: absolute;
    top: 70px;
    left: 20px;
    z-index: 20;
}

#controls button {
    padding: 6px 12px;
    border-radius: 6px;
    border: 1px solid #0b63b6;
    background: #e8f1ff;
    cursor: pointer;
    margin-right: 5px;
    font-size: 13px;
}
#controls button:hover {
    background: #d9e7ff;
}

/* ============================
   SEARCH BOX
   ============================ */
#searchBox {
    position: absolute;
    left: 50%;
    top: 80px;
    transform: translateX(-50%);
    width: 320px;
    padding: 8px 10px;
    border-radius: 8px;
    border: 1px solid #c5d3e8;
    box-shadow: 0 2px 6px rgba(0,0,0,0.15);
    z-index: 20;
}

/* ============================
   AUTHOR CREDITS PANEL
   ============================ */
#credits {
    position: absolute;
    top: 80px;
    right: 20px;
    width: 260px;
    background: white;
    border-radius: 8px;
    padding: 10px 12px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    font-size: 12px;
    line-height: 1.4;
    z-index: 20;
}
#credits b {
    display: block;
    margin-bottom: 6px;
}

/* ============================
   MAIN SVG + NODES + LINKS
   ============================ */
svg {
    width: 100%;
    height: calc(100vh - 60px);
    cursor: grab;
    user-select: none;
}

.node rect {
    rx: 10;
    ry: 10;
    stroke-width: 2;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.18));
}

.node text {
    font-size: 14px;
    pointer-events: none;
}

.node-number {
    font-size: 11px;
    font-weight: 600;
    fill: #333;
}

/* Underlined blue text for nodes with external links */
.linked text.label-text {
    text-decoration: underline;
    fill: #0b63b6;
}

.link {
    fill: none;
    stroke-width: 2.1px;
    opacity: 0.9;
}

/* red leaf marker */
.end-dot {
    fill: #d32f2f;
    stroke: #7f0000;
    stroke-width: 1.5;
}

/* Highlighted from search */
.highlight rect {
    stroke: #ffeb3b !important;
    stroke-width: 4px !important;
}

/* ============================
   TOOLTIP ON HOVER
   ============================ */
#tooltip {
    position: absolute;
    padding: 8px 10px;
    background: rgba(0,0,0,0.85);
    color: white;
    font-size: 13px;
    border-radius: 6px;
    display: none;
    max-width: 320px;
    z-index: 50;
    pointer-events: none;
}

/* ============================
   INTERACTIVE MINIMAP
   ============================ */
#minimap {
    position: absolute;
    bottom: 20px;
    right: 20px;
    border: 1px solid #777;
    width: 220px;
    height: 160px;
    background: white;
    z-index: 35;
    cursor: pointer;
}

#minimap-viewport {
    fill: rgba(0, 123, 255, 0.18);
    stroke: #0b63b6;
    stroke-width: 1.2px;
    pointer-events: none;
}
</style>
</head>

<body>

<header>Open Access & Open Science — Interactive Mindmap</header>

<!-- ============================
     CONTROL BUTTONS
     ============================ -->
<div id="controls">
    <button id="expandAllBtn">Expand All</button>
    <button id="collapseAllBtn">Collapse All</button>
    <button id="fitBtn">Fit to Screen</button>
    <button id="exportSvgBtn">Export SVG</button>
    <button id="exportPngBtn">Export PNG</button>
</div>

<!-- ============================
     SEARCH + CREDITS
     ============================ -->
<input id="searchBox" type="text" placeholder="Search node..." />

<div id="credits">
<b>Credits:</b>
Dr. Tamal Kumar Guha<br>
Librarian, IIT Guwahati<br><br>
Presented at NEHU, DLISc<br>
22 Nov 2025<br><br>
<i>Workshop:</i><br>
Research Support Services: Role of Libraries & Library Professionals in the Digital Landscape
</div>

<!-- ============================
     TOOLTIP
     ============================ -->
<div id="tooltip"></div>

<!-- ============================
     MAIN SVG (with wrapped viewport)
     ============================ -->
<svg id="mainSVG">
   <g id="viewport">
      <g id="links-layer"></g>
      <g id="nodes-layer"></g>
   </g>
</svg>

<!-- ============================
     INTERACTIVE MINIMAP
     ============================ -->
<svg id="minimap"></svg>
<script>
/* ============================================================
   CONFIGURATION
   ============================================================ */

const CSV_URL = "https://raw.githubusercontent.com/tkguha/oa/main/oaos.csv";

const ROOT_COLOR = "#0b63b6";    // Royal Blue root node
const VERT_SPACING = 55;         // vertical node separation
const DEPTH_SPACING = 160;       // horizontal separation
const MIN_SEP = 40;              // anti-overlap spacing
const BRANCH_COUNT_LEFT = 2;     // first 2 top branches on left side

/* Pastel Cool Blues */
const BRANCH_COLORS = [
    { fill: getPastel("--branch1"), stroke: getColor("--branch1-stroke") },
    { fill: getPastel("--branch2"), stroke: getColor("--branch2-stroke") },
    { fill: getPastel("--branch3"), stroke: getColor("--branch3-stroke") },
    { fill: getPastel("--branch4"), stroke: getColor("--branch4-stroke") }
];

function getColor(variable) {
    return getComputedStyle(document.documentElement).getPropertyValue(variable).trim();
}
function getPastel(variable) {
    return getComputedStyle(document.documentElement).getPropertyValue(variable).trim();
}

/* Animation Durations */
const NODE_DUR = 400;
const LINK_DUR = 350;

/* SVG Handles */
const svg = d3.select("#mainSVG");
const viewport = d3.select("#viewport");
const nodeLayer = d3.select("#nodes-layer");
const linkLayer = d3.select("#links-layer");
const minimap = d3.select("#minimap");

const tooltip = d3.select("#tooltip");
const searchBox = document.getElementById("searchBox");

/* For zoom/pan */
let width = window.innerWidth;
let height = window.innerHeight - 60;

const zoom = d3.zoom()
    .scaleExtent([0.25, 3.5])
    .on("zoom", e => viewport.attr("transform", e.transform));

svg.call(zoom);

/* ============================================================
   LOAD CSV AND BUILD HIERARCHY
   ============================================================ */
d3.csv("https://raw.githubusercontent.com/tkguha/oa/main/oaos.csv").then(rows => {

    /* Normalize rows */
    const data = rows.map(r => ({
        id: (r.node_id || "").trim(),
        parent: (r.parent_id || "").trim(),
        level: +r.level || 0,
        name: (r.topic || "").trim(),
        link: (r.links || "").trim(),
        details: (r.tags || "").trim()
    })).filter(r => r.id.length > 0);

    const map = new Map();
    data.forEach(r => map.set(r.id, { ...r, children: [] }));

    let rootData = null;
    map.forEach(node => {
        if (!node.parent) {
            rootData = node;
        } else if (map.has(node.parent)) {
            map.get(node.parent).children.push(node);
        }
    });

    if (!rootData) {
        alert("ERROR: No root node found.");
        return;
    }

    /* Build D3 hierarchy */
    const root = d3.hierarchy(rootData, d => d.children && d.children.length ? d.children : null);

    /* Sequential numbering */
    root.descendants().forEach((d, i) => d.data.seq = i + 1);

    /* Assign branch family + side (left/right) */
    if (root.children) {
        root.children.forEach((child, i) => {
            const side = i < BRANCH_COUNT_LEFT ? -1 : 1;
            const colorIndex = i % BRANCH_COLORS.length;
            assignBranch(child, colorIndex, side);
        });
    }

    function assignBranch(node, idx, side) {
        node.data.branch = idx;
        node.data.side = side;
        node.children?.forEach(ch => assignBranch(ch, idx, side));
    }

    /* Expand only top 2 levels */
    root.descendants().forEach(d => {
        if (d.depth <= 1) {
            d.children = d.children || d._children;
            d._children = null;
        } else {
            if (d.children) {
                d._children = d.children;
                d.children = null;
            }
        }
    });

    /* Tree layout */
    const tree = d3.tree().nodeSize([VERT_SPACING, DEPTH_SPACING]);

    /* Store global references */
    window._root = root;
    window._tree = tree;

    /* Initial render */
    update(root);

    /* Fit to screen after initial layout */
    setTimeout(fitToScreen, 700);

    /* Hook buttons */
    setupButtons(root);

    /* Hook search */
    setupSearch();

    /* Setup minimap */
    setupMinimap();
/* ============================================================
   MAIN RENDERING ENGINE — update()
   ============================================================ */
function update(source) {

    const root = window._root;
    const tree = window._tree;

    tree(root);

    const nodes = root.descendants();
    const links = root.links();

    /* -----------------------------------------
       Balanced Left/Right radial positioning
       ----------------------------------------- */
    nodes.forEach(d => {
        const side = d.data.side ?? (d.parent ? d.parent.data.side : 1);
        d.screenX = d.x;
        d.screenY = d.depth * DEPTH_SPACING * side;
    });

    /* -----------------------------------------
       Anti-overlap engine
       ----------------------------------------- */
    const groups = d3.group(nodes, d => d.depth);
    groups.forEach(group => {
        group.sort((a, b) => a.screenX - b.screenX);
        for (let i = 1; i < group.length; i++) {
            let prev = group[i - 1];
            let curr = group[i];
            if (curr.screenX - prev.screenX < MIN_SEP) {
                curr.screenX += (MIN_SEP - (curr.screenX - prev.screenX));
            }
        }
    });

    /* -----------------------------------------
       NODE JOIN
       ----------------------------------------- */
    const nodeSel = nodeLayer.selectAll("g.node")
        .data(nodes, d => d.data.id);

    const nodeEnter = nodeSel.enter()
        .append("g")
        .attr("class", "node")
        .attr("transform", `translate(${source.y0 || 0},${source.x0 || 0})`)
        .style("cursor", "pointer")
        .on("click", (e, d) => {
            if (d.data.link) {
                window.open(d.data.link, "_blank", "noopener");
            }
            centerNode(d);
        })
        .on("dblclick", (e, d) => {
            e.stopPropagation();
            toggle(d);
            update(d);
        })
        .on("mouseover", (e, d) => showTooltip(e, d))
        .on("mouseout", hideTooltip);

    nodeEnter.append("rect")
        .attr("width", 60)
        .attr("height", 20)
        .attr("x", -30)
        .attr("y", -10)
        .style("opacity", 0);

    nodeEnter.append("text")
        .attr("class", "node-number")
        .attr("text-anchor", "end")
        .attr("x", -8)
        .attr("y", -2)
        .text(d => d.data.seq + ".");

    nodeEnter.append("text")
        .attr("class", "label-text")
        .attr("x", 0)
        .attr("y", 4)
        .attr("text-anchor", "start")
        .text(d => d.data.name);

    const nodeMerge = nodeEnter.merge(nodeSel);

    /* -----------------------------------------
       Dynamic box sizing
       ----------------------------------------- */
    nodeMerge.each(function(d) {
        const g = d3.select(this);
        const num = g.select(".node-number").node().getBBox();
        const lab = g.select(".label-text").node().getBBox();

        const padX = 12, padY = 6;
        const width = num.width + lab.width + padX * 2 + 8;
        const height = Math.max(num.height, lab.height) + padY * 2;

        const fillStroke = colorForNode(d);

        g.select("rect")
            .attr("x", -width / 2)
            .attr("y", -height / 2)
            .attr("width", width)
            .attr("height", height)
            .style("fill", fillStroke.fill)
            .style("stroke", fillStroke.stroke);

        g.select(".node-number")
            .attr("x", -width/2 + padX + num.width)
            .attr("y", 4 - height/2 + padY);

        g.select(".label-text")
            .attr("x", -width/2 + padX + num.width + 8)
            .attr("y", 4 - height/2 + padY);

        if (d.depth === 0) {
            g.selectAll("text")
                .style("fill", "#ffffff")
                .style("font-weight", "600");
        } else if (d.data.link) {
            g.classed("linked", true);
        }
    });

    /* -----------------------------------------
       Node transition
       ----------------------------------------- */
    nodeMerge.transition().duration(NODE_DUR)
        .attr("transform", d => `translate(${d.screenY},${d.screenX})`);

    nodeSel.exit()
        .transition().duration(NODE_DUR)
        .style("opacity", 0)
        .remove();

    /* -----------------------------------------
       Red leaf dot
       ----------------------------------------- */
    nodeMerge.each(function(d) {
        const g = d3.select(this);
        g.select(".end-dot").remove();
        if (!d.children && !d._children) {
            const rect = g.select("rect").node().getBBox();
            const side = d.data.side || 1;
            g.append("circle")
                .attr("class", "end-dot")
                .attr("r", 5)
                .attr("cx", side > 0 ? rect.x + rect.width + 10 : rect.x - 10)
                .attr("cy", 0);
        }
    });

    /* -----------------------------------------
       LINK JOIN
       ----------------------------------------- */
    const linkSel = linkLayer.selectAll("path.link")
        .data(links, d => d.target.data.id);

    const linkEnter = linkSel.enter()
        .append("path")
        .attr("class", "link")
        .attr("d", d => linkCurve(source, source));

    linkEnter.merge(linkSel)
        .style("stroke", d => colorForNode(d.target).stroke)
        .transition().duration(LINK_DUR)
        .attr("d", d => linkCurve(d.source, d.target));

    linkSel.exit()
        .transition().duration(LINK_DUR)
        .style("opacity", 0)
        .remove();

    /* -----------------------------------------
       Save positions for smooth transitions
       ----------------------------------------- */
    nodes.forEach(d => {
        d.x0 = d.screenX;
        d.y0 = d.screenY;
    });

    /* -----------------------------------------
       Update minimap
       ----------------------------------------- */
    updateMinimap();
}

/* ============================================================
   NODE COLORING LOGIC
   ============================================================ */
function colorForNode(d) {
    if (d.depth === 0) {
        return { fill: ROOT_COLOR, stroke: ROOT_COLOR };
    }
    const idx = d.data.branch ?? 0;
    return BRANCH_COLORS[idx % BRANCH_COLORS.length];
}

/* ============================================================
   LINK CURVE (smooth Bézier)
   ============================================================ */
function linkCurve(s, t) {
    const sx = s.screenY, sy = s.screenX;
    const tx = t.screenY, ty = t.screenX;
    const dx = (tx - sx) * 0.55;
    return `M${sx},${sy} C${sx+dx},${sy} ${tx-dx},${ty} ${tx},${ty}`;
}

/* ============================================================
   NODE TOGGLE (collapse/expand)
   ============================================================ */
function toggle(d) {
    if (d.children) {
        d._children = d.children;
        d.children = null;
    } else {
        d.children = d._children;
        d._children = null;
    }
}

/* ============================================================
   CLICK-TO-CENTER ANIMATION
   ============================================================ */
function centerNode(d) {
    const x = d.screenX;
    const y = d.screenY;

    svg.transition()
        .duration(700)
        .call(
            zoom.transform,
            d3.zoomIdentity
                .translate(width / 2 - y, height / 2 - x)
                .scale(1.0)
        );
}

/* ============================================================
   EXPAND / COLLAPSE ALL
   ============================================================ */
function expandAll(d) {
    if (d._children) {
        d.children = d._children;
        d._children = null;
    }
    if (d.children) {
        d.children.forEach(expandAll);
    }
}

function collapseAll(d) {
    if (d.children) {
        d._children = d.children;
        d.children = null;
    }
    if (d._children) {
        d._children.forEach(collapseAll);
    }
}

function setupButtons(root) {
    document.getElementById("expandAllBtn").onclick = () => {
        expandAll(root);
        update(root);
    };

    document.getElementById("collapseAllBtn").onclick = () => {
        root.children.forEach(collapseAll);
        update(root);
    };

    document.getElementById("fitBtn").onclick = fitToScreen;

    document.getElementById("exportSvgBtn").onclick = exportSVG;
    document.getElementById("exportPngBtn").onclick = exportPNG;
}

/* ============================================================
   FIT TO SCREEN
   ============================================================ */
function fitToScreen() {
    const box = viewport.node().getBBox();
    const margin = 40;

    const scale = Math.min(
        (width - margin) / box.width,
        (height - margin) / box.height
    );

    const s = Math.max(0.3, Math.min(scale, 1.6));

    const tx = (width - box.width * s) / 2 - box.x * s;
    const ty = (height - box.height * s) / 2 - box.y * s;

    svg.transition()
        .duration(700)
        .call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(s));
}

/* ============================================================
   TOOLTIP
   ============================================================ */
function showTooltip(e, d) {
    if (!d.data.details) return;
    tooltip.style("display", "block")
        .style("left", (e.pageX + 14) + "px")
        .style("top", (e.pageY + 14) + "px")
        .html(d.data.details);
}
function hideTooltip() {
    tooltip.style("display", "none");
}

/* ============================================================
   SEARCH ENGINE
   ============================================================ */
function setupSearch() {
    searchBox.addEventListener("input", () => {
        const q = searchBox.value.trim().toLowerCase();
        const nodes = nodeLayer.selectAll("g.node");

        nodes.classed("highlight", false);
        if (!q) return;

        const matches = nodes.filter(d =>
            d.data.name.toLowerCase().includes(q)
        );

        matches.classed("highlight", true);

        const first = matches.datum();
        if (first) centerNode(first);
    });
}

/* ============================================================
   EXPORT SVG
   ============================================================ */
function exportSVG() {
    const svgData = new XMLSerializer().serializeToString(document.querySelector("svg"));
    const blob = new Blob([svgData], { type: "image/svg+xml" });
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = "mindmap.svg";
    a.click();

    URL.revokeObjectURL(url);
}

/* ============================================================
   EXPORT PNG
   ============================================================ */
function exportPNG() {
    const svgNode = document.querySelector("svg");
    const svgData = new XMLSerializer().serializeToString(svgNode);

    const img = new Image();
    const svgBlob = new Blob([svgData], { type: "image/svg+xml" });
    const url = URL.createObjectURL(svgBlob);

    img.onload = function () {
        const c = document.createElement("canvas");
        c.width = svgNode.clientWidth * 2;
        c.height = svgNode.clientHeight * 2;

        const ctx = c.getContext("2d");
        ctx.scale(2, 2);
        ctx.drawImage(img, 0, 0);

        const png = c.toDataURL("image/png");

        const a = document.createElement("a");
        a.href = png;
        a.download = "mindmap.png";
        a.click();

        URL.revokeObjectURL(url);
    };
    img.src = url;
}

/* ============================================================
   INTERACTIVE MINIMAP
   ============================================================ */
function setupMinimap() {
    minimap.html(""); // clear

    const miniG = minimap.append("g").attr("id", "mini-root");

    window._miniG = miniG;

    minimap.on("click", (e) => {
        const pt = d3.pointer(e, minimap.node());
        const scale = minimap.node().clientWidth / width;
        const tx = width/2 - pt[0] / scale;
        const ty = height/2 - pt[1] / scale;

        svg.transition().duration(400)
            .call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(1));
    });
}

function updateMinimap() {
    const miniG = window._miniG;
    if (!miniG) return;

    miniG.html("");

    const cloned = viewport.node().cloneNode(true);
    miniG.node().appendChild(cloned);

    const scale = minimap.node().clientWidth / (width * 3);
    miniG.attr("transform", `scale(${scale})`);

    /* Viewport rectangle on minimap */
    const t = d3.zoomTransform(svg.node());

    const rectW = minimap.node().clientWidth / t.k;
    const rectH = minimap.node().clientHeight / t.k;

    minimap.select("#minimap-viewport").remove();

    minimap.append("rect")
        .attr("id", "minimap-viewport")
        .attr("x", -t.x / t.k * scale)
        .attr("y", -t.y / t.k * scale)
        .attr("width", rectW * scale)
        .attr("height", rectH * scale);
}
</script>

</body>
</html>


