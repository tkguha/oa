<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Open Access & Open Science — Interactive Mindmap</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
  :root {
    --bg: #f5f7fb;
    --header-bg: #0b63b6;
    --header-fg: #ffffff;
    --node-text: #102a43;
    --node-bg: #ffffff;
  }

  * { box-sizing: border-box; }

  body {
    margin: 0;
    font-family: "Segoe UI", Arial, sans-serif;
    background: var(--bg);
  }

  header {
    background: var(--header-bg);
    color: var(--header-fg);
    padding: 10px 18px;
    font-size: 20px;
    font-weight: 600;
    text-align: center;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
  }

  header .controls {
    position: absolute;
    left: 16px;
    display: flex;
    gap: 6px;
  }

  header button {
    border: 1px solid #0b63b6;
    background: #ffffff;
    color: #0b63b6;
    font-size: 12px;
    padding: 5px 10px;
    border-radius: 6px;
    cursor: pointer;
  }
  header button:hover {
    background:#e3f2fd;
  }

  #canvas {
    position: relative;
    height: calc(100vh - 48px);
    overflow: hidden;
  }

  #searchBox {
    position: absolute;
    top: 12px;
    left: 50%;
    transform: translateX(-50%);
    width: 320px;
    padding: 7px 10px;
    border-radius: 8px;
    border: 1px solid #cfd8e3;
    font-size: 14px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.15);
    z-index: 20;
  }

  #credits {
    position: absolute;
    right: 16px;
    top: 12px;
    max-width: 260px;
    background:#ffffff;
    border-radius:8px;
    padding:8px 10px;
    box-shadow:0 2px 8px rgba(0,0,0,0.18);
    font-size:12px;
    line-height:1.4;
    z-index:21;
  }
  #credits b{display:block;margin-bottom:4px;}

  #tooltip {
    position: absolute;
    padding: 6px 8px;
    background: rgba(0,0,0,0.86);
    color:#fff;
    font-size: 12px;
    border-radius: 6px;
    display:none;
    pointer-events:none;
    z-index:40;
    max-width:280px;
  }

  svg.main {
    width:100%;
    height:100%;
    display:block;
    cursor: grab;
  }

  svg.minimap {
    width:260px;
    height:180px;
    border:1px solid #cfd8e3;
    background:#ffffff;
    position:absolute;
    right:16px;
    bottom:16px;
    box-shadow:0 2px 6px rgba(0,0,0,0.12);
    z-index:10;
  }

  .node rect {
    rx: 10;
    ry: 10;
    stroke-width: 1.8px;
    filter: drop-shadow(0 1px 2px rgba(0,0,0,0.2));
  }

  .node text.label {
    font-size: 14px;
    fill: var(--node-text);
    pointer-events: none;
  }

  .node text.seq {
    font-size: 11px;
    fill:#555;
    pointer-events:none;
    font-weight:600;
  }

  .node.linked text.label {
    fill:#0b63b6;
    text-decoration: underline;
  }

  .link {
    fill:none;
    stroke-width:2px;
    opacity:0.95;
  }

  .end-dot {
    fill:#d32f2f;
    stroke:#b00000;
    stroke-width:1.4;
  }

  .highlight rect {
    stroke:#ffeb3b !important;
    stroke-width:4px !important;
  }
</style>
</head>
<body>
<header>
  <div class="controls">
    <button id="btnExpand">Expand All</button>
    <button id="btnCollapse">Collapse All</button>
    <button id="btnFit">Fit to Screen</button>
    <button id="btnExportSVG">Export SVG</button>
    <button id="btnExportPNG">Export PNG</button>
  </div>
  <span>Open Access &amp; Open Science — Interactive Mindmap</span>
</header>

<div id="canvas">
  <input id="searchBox" type="text" placeholder="Search node..." />
  <div id="credits">
    <b>Credits</b>
    Dr. Tamal Kumar Guha,<br/>
    Librarian, IIT Guwahati<br/><br/>
    Presented at a Workshop on 22nd Nov. 2025 at NEHU, DLISc<br/>
    <i>Workshop Title:</i> Research Support Services: Role of Libraries and Library
    Professionals in the Digital Landscape
  </div>
  <div id="tooltip"></div>

  <svg class="main">
    <g id="linksLayer"></g>
    <g id="nodesLayer"></g>
  </svg>

  <!-- Mini-map -->
  <svg class="minimap">
    <g id="miniLinks"></g>
    <g id="miniNodes"></g>
    <rect id="miniViewport" fill="none" stroke="#ff6f00" stroke-width="1.5"></rect>
  </svg>
</div>

<script>
const CSV_URL = "https://raw.githubusercontent.com/tkguha/oa/main/oaos.csv";

// layout constants
const VERT_SPACING = 50;
const DEPTH_SPACING = 160;
const MIN_SEP = 40;         // minimum vertical gap for anti-overlap
const LEFT_COUNT = 2;       // first 2 root branches on left
const NODE_DUR = 220;
const LINK_DUR = 220;

const BRANCH_COLORS = [
  "#1976d2", // left1
  "#2e7d32", // left2
  "#fb8c00", // right1
  "#6a1b9a"  // right2
];

const svg     = d3.select("svg.main");
const linkG  = d3.select("#linksLayer");
const nodeG  = d3.select("#nodesLayer");
const mini   = d3.select("svg.minimap");
const miniLinks = d3.select("#miniLinks");
const miniNodes = d3.select("#miniNodes");
const miniViewport = d3.select("#miniViewport");
const tooltip = d3.select("#tooltip");

const searchBox = document.getElementById("searchBox");

// zoom on main SVG
const zoom = d3.zoom()
  .scaleExtent([0.25, 3])
  .on("zoom", event => {
    nodeG.attr("transform", event.transform);
    linkG.attr("transform", event.transform);
    updateMiniViewport(event.transform);
  });

svg.call(zoom);

const width  = () => svg.node().clientWidth;
const height = () => svg.node().clientHeight;

// ===== LOAD CSV =====
d3.csv("https://raw.githubusercontent.com/tkguha/oa/main/oaos.csv").then(raw => {
  if (!raw || !raw.length) {
    alert("CSV loaded but no rows found.");
    return;
  }

  // normalize rows
  const rows = raw.map(r => ({
    id:       (r.node_id   || "").trim(),
    parentId: (r.parent_id || "").trim(),
    level:    +r.level || 0,
    topic:    (r.topic || "").trim(),
    link:     (r.links || "").trim()
  })).filter(r => r.id);

  // build map
  const map = new Map();
  rows.forEach(r => map.set(r.id, Object.assign(r, {children: []})));

  let rootData = null;
  map.forEach(n => {
    if (!n.parentId) {
      rootData = n;
    } else if (map.has(n.parentId)) {
      map.get(n.parentId).children.push(n);
    }
  });

  if (!rootData) {
    alert("No root node found (missing row with empty parent_id).");
    return;
  }

  const root = d3.hierarchy(rootData, d =>
    d.children && d.children.length ? d.children : null
  );

  // sequential numbering (pre-order)
  root.descendants().forEach((d,i) => d.data.seq = i + 1);

  // assign branch + side
  if (root.children) {
    root.children.forEach((c,i) => {
      const side = (i < LEFT_COUNT) ? -1 : 1;
      const branch = i % BRANCH_COLORS.length;
      assignBranchAndSide(c, branch, side);
    });
  }

  // collapse deeper than level 2 (depth > 2)
  root.descendants().forEach(d => {
    if (d.depth > 2 && d.children) {
      d._children = d.children;
      d.children = null;
    }
  });

  const treeLayout = d3.tree().nodeSize([VERT_SPACING, 100]);

  root.x0 = 0;
  root.y0 = 0;

  update(root);
  setTimeout(() => fitToScreen(), 600);

  // button handlers
  document.getElementById("btnExpand").onclick = () => { expandAll(root); update(root); fitToScreen(); };
  document.getElementById("btnCollapse").onclick = () => { collapseAll(root); update(root); fitToScreen(); };
  document.getElementById("btnFit").onclick = () => { fitToScreen(); };
  document.getElementById("btnExportSVG").onclick = () => exportSVG();
  document.getElementById("btnExportPNG").onclick = () => exportPNG();

  // search
  searchBox.addEventListener("input", () => {
    const q = searchBox.value.trim().toLowerCase();
    const nodesSel = nodeG.selectAll("g.node");
    nodesSel.classed("highlight", false);
    if (!q) return;
    const matches = nodesSel.filter(d =>
      (d.data.topic || "").toLowerCase().includes(q)
    );
    matches.classed("highlight", true);
    const first = matches.datum();
    if (first) centerOn(first);
  });

  // === FUNCTIONS ===
  function assignBranchAndSide(node, branch, side) {
    node.data.branch = branch;
    node.data.side = side;
    node.children && node.children.forEach(c => assignBranchAndSide(c, branch, side));
    node._children && node._children.forEach(c => assignBranchAndSide(c, branch, side));
  }

  function expandAll(node) {
    if (node._children) {
      node.children = node._children;
      node._children = null;
    }
    node.children && node.children.forEach(expandAll);
  }
  function collapseAll(node) {
    node.children && node.children.forEach(child => {
      collapseAll(child);
      child._children = child.children;
      child.children = null;
    });
  }

  function colorFor(d) {
    if (d.depth === 0) {
      return { fill:"#08306b", stroke:"#08306b" };
    }
    const idx = d.data.branch ?? 0;
    const base = BRANCH_COLORS[idx % BRANCH_COLORS.length];
    const t = Math.min(d.depth/4, 0.6);
    return {
      fill: d3.interpolateRgb(base, "#ffffff")(t),
      stroke: d3.color(base).darker(0.8).formatHex()
    };
  }

  function update(source) {
    // compute layout
    treeLayout(root);
    const nodes = root.descendants();
    const links = root.links();

    nodes.forEach(d => {
      const side = d.data.side !== undefined
        ? d.data.side
        : (d.parent ? d.parent.data.side || 1 : 1);
      d.screenX = d.x;
      d.screenY = d.depth * DEPTH_SPACING * side;
    });

    // anti-overlap per depth
    const depthGroups = d3.group(nodes, d => d.depth);
    depthGroups.forEach(group => {
      group.sort((a,b) => a.screenX - b.screenX);
      for (let i=1;i<group.length;i++){
        const prev = group[i-1];
        const curr = group[i];
        if (curr.screenX - prev.screenX < MIN_SEP) {
          const shift = MIN_SEP - (curr.screenX - prev.screenX);
          curr.screenX += shift;
        }
      }
    });

    // NODES
    const nodeSel = nodeG.selectAll("g.node")
      .data(nodes, d => d.data.id);

    const nodeEnter = nodeSel.enter()
      .append("g")
      .attr("class","node")
      .attr("transform", `translate(${source.y0 || 0},${source.x0 || 0})`)
      .style("cursor","pointer")
      .on("click", (event,d) => {
        centerOn(d);
        if (d.data.link) {
          window.open(d.data.link,"_blank","noopener");
        }
      })
      .on("dblclick", (event,d) => {
        event.stopPropagation();
        if (d.children) {
          d._children = d.children;
          d.children = null;
        } else {
          d.children = d._children;
          d._children = null;
        }
        update(d);
      });

    nodeEnter.append("rect")
      .attr("width",40)
      .attr("height",20)
      .attr("x",-20)
      .attr("y",-10)
      .style("opacity",0);

    nodeEnter.append("text")
      .attr("class","seq")
      .attr("text-anchor","end")
      .attr("x",-6)
      .attr("y",-1)
      .text(d => d.data.seq + ".");

    nodeEnter.append("text")
      .attr("class","label")
      .attr("text-anchor","start")
      .attr("x",0)
      .attr("y",4)
      .text(d => d.data.topic || d.data.id);

    // size rects & apply colors
    nodeEnter.each(function(d){
      const gSel = d3.select(this);
      const seqBB = gSel.select("text.seq").node().getBBox();
      const labBB = gSel.select("text.label").node().getBBox();
      const padX=10, padY=6;
      const w = seqBB.width + labBB.width + padX*2 + 6;
      const h = Math.max(seqBB.height, labBB.height) + padY*2;

      const {fill,stroke} = colorFor(d);

      gSel.select("rect")
        .attr("x",-w/2)
        .attr("y",-h/2)
        .attr("width",w)
        .attr("height",h)
        .style("fill",fill)
        .style("stroke",stroke);

      const offsetLeft = -w/2 + padX;
      gSel.select("text.seq")
        .attr("x", offsetLeft + seqBB.width)
        .attr("y", 4 - h/2 + padY);

      gSel.select("text.label")
        .attr("x", offsetLeft + seqBB.width + 6)
        .attr("y", 4 - h/2 + padY);

      if (d.depth === 0) {
        gSel.selectAll("text")
          .style("fill","#ffffff")
          .style("font-weight","600");
      } else if (d.data.link) {
        gSel.classed("linked", true);
      }
    });

    // merge + transition
    const nodeMerge = nodeEnter.merge(nodeSel);
    nodeMerge.transition().duration(NODE_DUR)
      .attr("transform", d => `translate(${d.screenY},${d.screenX})`);

    // leaf dots
    nodeMerge.each(function(d){
      const gSel = d3.select(this);
      gSel.select("circle.end-dot").remove();
      if (!d.children && !d._children) {
        const rect = gSel.select("rect").node().getBBox();
        const side = d.data.side ?? (d.parent ? d.parent.data.side || 1 : 1);
        const cx = side >= 0 ? rect.x + rect.width + 10 : rect.x - 10;
        gSel.append("circle")
          .attr("class","end-dot")
          .attr("r",5)
          .attr("cx",cx)
          .attr("cy",0);
      }
    });

    nodeSel.exit()
      .transition().duration(NODE_DUR)
      .style("opacity",0)
      .remove();

    // LINKS
    const linkSel = linkG.selectAll("path.link")
      .data(links, d => d.target.data.id);

    const linkEnter = linkSel.enter()
      .append("path")
      .attr("class","link")
      .attr("d", d => pathCurve(source, source))
      .style("stroke-dasharray", function(){
        const len = this.getTotalLength ? this.getTotalLength() : 0;
        return len+" "+len;
      })
      .style("stroke-dashoffset", function(){
        return this.getTotalLength ? this.getTotalLength() : 0;
      });

    linkEnter.merge(linkSel)
      .style("stroke", d => colorFor(d.target).stroke)
      .transition().duration(LINK_DUR)
      .attr("d", d => pathCurve(d.source, d.target))
      .style("stroke-dashoffset",0);

    linkSel.exit()
      .transition().duration(LINK_DUR)
      .style("opacity",0)
      .remove();

    nodes.forEach(d => { d.x0 = d.screenX; d.y0 = d.screenY; });

    // update minimap
    drawMini(nodes, links);
  }

  function pathCurve(s,d){
    const x1 = s.screenY ?? s.y0, y1 = s.screenX ?? s.x0;
    const x2 = d.screenY ?? d.y0, y2 = d.screenX ?? d.x0;
    const k = 0.55;
    const cx1 = x1 + (x2 - x1) * k;
    const cx2 = x2 - (x2 - x1) * k;
    return `M${x1},${y1} C${cx1},${y1} ${cx2},${y2} ${x2},${y2}`;
  }

  function getBBoxAll(){
    const box = nodeG.node().getBBox();
    return box;
  }

  function fitToScreen(){
    try{
      const box = getBBoxAll();
      const w = width(), h = height();
      const margin = 80;
      const scale = Math.min(
        (w - margin)/box.width,
        (h - margin)/box.height
      );
      const s = Math.max(0.25, Math.min(scale, 1.8));
      const tx = (w - box.width*s)/2 - box.x*s;
      const ty = (h - box.height*s)/2 - box.y*s;
      svg.transition().duration(450)
        .call(zoom.transform,
          d3.zoomIdentity.translate(tx,ty).scale(s)
        );
    } catch(e){
      console.warn("fitToScreen error",e);
    }
  }

  function centerOn(d){
    const w = width(), h = height();
    const scale = d3.zoomTransform(svg.node()).k;
    const x = d.screenY;
    const y = d.screenX;
    const tx = w/2 - x*scale;
    const ty = h/2 - y*scale;
    svg.transition().duration(400)
      .call(zoom.transform,
        d3.zoomIdentity.translate(tx,ty).scale(scale)
      );
  }

  // MINIMAP DRAW
  function drawMini(nodes, links){
    const box = getBBoxAll();
    const mw = mini.node().clientWidth;
    const mh = mini.node().clientHeight;
    const scale = Math.min(mw/box.width, mh/box.height)*0.9;
    const tx = (mw - box.width*scale)/2 - box.x*scale;
    const ty = (mh - box.height*scale)/2 - box.y*scale;

    const transform = d3.zoomIdentity.translate(tx,ty).scale(scale);

    const mLinks = miniLinks.selectAll("path").data(links, d=>d.target.data.id);
    mLinks.enter().append("path").merge(mLinks)
      .attr("d", d => {
        const s = transform.apply([d.source.screenY, d.source.screenX]);
        const t = transform.apply([d.target.screenY, d.target.screenX]);
        return `M${s[0]},${s[1]} L${t[0]},${t[1]}`;
      })
      .attr("stroke","#c1cad9")
      .attr("stroke-width",1)
      .attr("fill","none");
    mLinks.exit().remove();

    const mNodes = miniNodes.selectAll("circle").data(nodes, d=>d.data.id);
    mNodes.enter().append("circle").merge(mNodes)
      .attr("r",2)
      .attr("cx", d => transform.apply([d.screenY,d.screenX])[0])
      .attr("cy", d => transform.apply([d.screenY,d.screenX])[1])
      .attr("fill","#546e7a");
    mNodes.exit().remove();

    // viewport rect will be updated by updateMiniViewport on zoom
    updateMiniViewport(d3.zoomTransform(svg.node()), transform, box);
  }

  function updateMiniViewport(mainTransform, miniTransform, box){
    if (!miniTransform || !box){
      const b = getBBoxAll();
      const mw = mini.node().clientWidth;
      const mh = mini.node().clientHeight;
      const scale = Math.min(mw/b.width, mh/b.height)*0.9;
      miniTransform = d3.zoomIdentity
        .translate((mw-b.width*scale)/2 - b.x*scale,
                   (mh-b.height*scale)/2 - b.y*scale)
        .scale(scale);
      box = b;
    }
    const mw = mini.node().clientWidth;
    const mh = mini.node().clientHeight;

    const invMain = mainTransform.invert([0,0]);
    const invMainBR = mainTransform.invert([width(), height()]);

    const topLeft  = miniTransform.apply(invMain);
    const botRight = miniTransform.apply(invMainBR);

    miniViewport
      .attr("x", topLeft[0])
      .attr("y", topLeft[1])
      .attr("width",  botRight[0] - topLeft[0])
      .attr("height", botRight[1] - topLeft[1]);
  }

  // EXPORT SVG
  function exportSVG(){
    const clone = svg.node().cloneNode(true);
    clone.removeAttribute("style");
    const outer = document.createElementNS("http://www.w3.org/2000/svg","svg");
    outer.setAttribute("xmlns","http://www.w3.org/2000/svg");
    outer.setAttribute("width", width());
    outer.setAttribute("height", height());
    outer.setAttribute("viewBox", `0 0 ${width()} ${height()}`);
    outer.appendChild(clone);
    const serializer = new XMLSerializer();
    const source = serializer.serializeToString(outer);
    const blob = new Blob([source],{type:"image/svg+xml;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "open_access_open_science_mindmap.svg";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  // EXPORT PNG
  function exportPNG(){
    const serializer = new XMLSerializer();
    const clone = svg.node().cloneNode(true);
    const outer = document.createElementNS("http://www.w3.org/2000/svg","svg");
    outer.setAttribute("xmlns","http://www.w3.org/2000/svg");
    outer.setAttribute("width", width());
    outer.setAttribute("height", height());
    outer.setAttribute("viewBox", `0 0 ${width()} ${height()}`);
    outer.appendChild(clone);
    const source = serializer.serializeToString(outer);
    const svgBlob = new Blob([source],{type:"image/svg+xml;charset=utf-8"});
    const url = URL.createObjectURL(svgBlob);

    const img = new Image();
    img.onload = function(){
      const canvas = document.createElement("canvas");
      canvas.width = width();
      canvas.height = height();
      const ctx = canvas.getContext("2d");
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.drawImage(img,0,0);
      URL.revokeObjectURL(url);
      canvas.toBlob(function(blob){
        const a = document.createElement("a");
        const url2 = URL.createObjectURL(blob);
        a.href = url2;
        a.download = "open_access_open_science_mindmap.png";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url2);
      });
    };
    img.src = url;
  }

}).catch(err => {
  console.error("Error loading CSV:",err);
  alert("Failed to load CSV data. Check console for details.");
});
</script>
</body>
</html>
