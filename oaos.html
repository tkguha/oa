<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Open Access and Open Science Mindmap</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
  :root{
    --bg:#f4f6fb;
    --header-bg:#08306b;
    --font:"Segoe UI",Roboto,Arial,sans-serif;
  }
  html,body{
    margin:0;
    height:100%;
    font-family:var(--font);
    background:var(--bg);
  }
  #container{
    width:100%;
    height:100%;
    position:relative;
  }
  #titleBar{
    background:var(--header-bg);
    color:#fff;
    padding:10px 16px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    box-sizing:border-box;
  }
  #titleText{
    font-size:20px;
    font-weight:700;
  }
  #controls{
    display:flex;
    gap:8px;
    align-items:center;
  }
  button.ctrl-btn{
    border:1px solid #d0d7de;
    background:#fff;
    padding:6px 10px;
    font-size:13px;
    border-radius:6px;
    cursor:pointer;
    box-shadow:0 1px 3px rgba(0,0,0,0.15);
  }
  button.ctrl-btn:hover{
    background:#f3f4f6;
  }

  #searchWrap{
    margin-left:8px;
    position:relative;
  }
  #searchBox{
    padding:6px 10px;
    border-radius:6px;
    border:1px solid #cfd8e3;
    font-size:13px;
    width:240px;
  }
  #suggestions{
    position:absolute;
    left:0;
    top:30px;
    width:100%;
    background:#fff;
    border:1px solid #d0d7de;
    border-radius:6px;
    box-shadow:0 4px 10px rgba(0,0,0,0.15);
    max-height:220px;
    overflow:auto;
    z-index:300;
    font-size:13px;
  }
  .suggest-item{
    padding:6px 8px;
    cursor:pointer;
  }
  .suggest-item:hover{
    background:#f1f5fb;
  }

  #mainArea{
    position:relative;
    width:100%;
    height:calc(100% - 48px);
    overflow:hidden;
  }
  #mindmap{
    width:100%;
    height:100%;
    display:block;
    cursor:grab;
    background:#f9fbff;
  }

  /* Credit box top-right */
  #creditBox{
    position:absolute;
    right:16px;
    top:60px;
    background:rgba(255,255,255,0.96);
    border-radius:8px;
    padding:8px 10px;
    font-size:12px;
    box-shadow:0 2px 6px rgba(0,0,0,0.15);
    z-index:250;
    max-width:260px;
  }
  #creditBox strong{
    display:block;
    margin-bottom:4px;
  }

  /* Tooltip */
  #tooltip{
    position:absolute;
    padding:8px 12px;
    background:#fff;
    border:1px solid #ccc;
    border-radius:6px;
    box-shadow:0 2px 6px rgba(0,0,0,0.2);
    pointer-events:none;
    display:none;
    font-size:13px;
    max-width:320px;
    white-space:normal;
    z-index:260;
  }

  /* Mini-map */
  #minimap{
    position:absolute;
    right:16px;
    bottom:16px;
    width:220px;
    height:160px;
    background:#ffffff;
    border:1px solid #cfd8e3;
    border-radius:6px;
    box-shadow:0 2px 8px rgba(0,0,0,0.25);
    z-index:240;
  }
  #minimap svg{
    width:100%;
    height:100%;
    display:block;
  }

  /* Node styles */
  .node text.label{
    font-size:14px;
    font-weight:500;
    pointer-events:none;
    fill:#071126;
  }
  .node text.id-label{
    font-size:11px;
    fill:#6b7280;
    pointer-events:none;
  }
  .node rect{
    rx:10;
    ry:10;
    stroke-width:2px;
    filter:drop-shadow(0 1px 2px rgba(0,0,0,0.15));
  }
  .link{
    fill:none;
    stroke-width:2px;
    opacity:0.95;
  }
  .end-dot{
    fill:#d32f2f;
    stroke:#b00000;
    stroke-width:1.4;
  }
  .highlight rect{
    stroke:#ffeb3b !important;
    stroke-width:4px;
  }
</style>
</head>
<body>
<div id="container">
  <div id="titleBar">
    <div id="titleText">OPEN SCIENCE AND OPEN ACCESS</div>
    <div id="controls">
      <button id="btnSvg" class="ctrl-btn">Download SVG</button>
      <button id="btnPng" class="ctrl-btn">Download PNG</button>

      <div id="searchWrap">
        <input id="searchBox" type="text" placeholder="Search node by text or ID…">
        <div id="suggestions" style="display:none;"></div>
      </div>
    </div>
  </div>

  <div id="mainArea">
    <svg id="mindmap">
      <g id="linksLayer"></g>
      <g id="nodesLayer"></g>
    </svg>

    <div id="creditBox">
      <strong>Dr. Tamal Kumar Guha</strong>
      <div>Librarian, IIT Guwahati</div>
      <div><b>Conceptual map of “Open Access & Open Science”.</b></div>
      <div>Presented in a workshop at NEHU-DLISc on 22nd Nov. 2025</div>
    </div>

    <div id="tooltip"></div>

    <div id="minimap">
      <svg>
        <g id="miniLinks"></g>
        <g id="miniNodes"></g>
        <rect id="miniView" fill="none" stroke="#ff5722" stroke-width="1.5"></rect>
      </svg>
    </div>
  </div>
</div>

<script>
// ============================
// CONFIG
// ============================
const CSV_URL = "https://raw.githubusercontent.com/tkguha/oa/main/oaos.csv";
const STORAGE_KEY = "OPEN_SCIENCE_AND_OPEN_ACCESS";
const ROOT_ID = "1";
const LEFT_COUNT = 2;

const VERT_SPACING = 40;
const DEPTH_SPACING = 140;
const NODE_DUR = 180;
const LINK_DUR = 180;

// Branch colors (Option B)
const BRANCH_BASE = [
  "#1976d2", // left 1 - blue
  "#2e7d32", // left 2 - green
  "#fb8c00", // right 1 - orange
  "#6a1b9a"  // right 2 - purple
];
const ROOT_FILL = "#08306b";
const ROOT_STROKE = "#08306b";

// ============================
// SVG + layers
// ============================
const svg = d3.select("#mindmap");
const linksLayer = d3.select("#linksLayer");
const nodesLayer = d3.select("#nodesLayer");
const tooltip = d3.select("#tooltip");

const miniSvg = d3.select("#minimap svg");
const miniLinks = d3.select("#miniLinks");
const miniNodes = d3.select("#miniNodes");
const miniView  = d3.select("#miniView");

const searchInput = document.getElementById("searchBox");
const suggestionsBox = document.getElementById("suggestions");

let currentTransform = d3.zoomIdentity;
let lastNodes = [];
let lastLinks = [];

// Zoom / pan
const zoom = d3.zoom().scaleExtent([0.25,3]).on("zoom", e => {
  currentTransform = e.transform;
  linksLayer.attr("transform", e.transform);
  nodesLayer.attr("transform", e.transform);
  updateMinimap(lastNodes, lastLinks);
});
svg.call(zoom);

const W = () => svg.node().clientWidth;
const H = () => svg.node().clientHeight;

// ============================
// LOAD CSV & BUILD TREE
// ============================
d3.csv(CSV_URL).then(data => {
  // map CSV -> internal structure
  const rows = data.map(r => ({
    ID: (r.node_id||"").trim(),
    ParentID: (r.parent_id||"").trim(),
    Level: +(r.level||"0"),
    Name: (r.topic||"").trim(),
    Details: (r.tags||"").trim(),
    PhotoURL: (r.links||"").trim()
  })).filter(r => r.ID);

  const byId = new Map();
  rows.forEach(r => byId.set(r.ID, { ...r, children: [] }));

  let rootRow = null;
  rows.forEach(r => {
    if(!r.ParentID){
      if(!rootRow) rootRow = byId.get(r.ID);
    } else if(byId.has(r.ParentID)) {
      byId.get(r.ParentID).children.push(byId.get(r.ID));
    }
  });
  if(!rootRow && byId.has(ROOT_ID)) rootRow = byId.get(ROOT_ID);
  if(!rootRow) rootRow = rows[0];

  const root = d3.hierarchy(rootRow, d => d.children && d.children.length ? d.children : null);
  root.x0 = 0; root.y0 = 0;

  // assign branch & side for first-level
  if(root.children){
    root.children.forEach((c,i)=>{
      const branchIndex = i % BRANCH_BASE.length;
      const side = (i < LEFT_COUNT) ? -1 : 1;
      assignBranch(c, branchIndex, side);
    });
  }

  // auto-save: restore expanded state if exists
  const savedExpanded = loadExpanded();
  if(savedExpanded && savedExpanded.size > 0){
    collapseAll(root);
    expandFromSaved(root, savedExpanded);
  } else {
    // default: collapse all, expand first-level
    collapseAll(root);
    root.children?.forEach(c => { c.children = c._children; c._children = null; });
  }

  const allNodesForSearch = [];
  root.each(d => allNodesForSearch.push(d));
  buildSearch(allNodesForSearch);

  update(root);
  setTimeout(()=>fitToContent(),600);

  // ========== helpers ==========
  function assignBranch(node, branchIndex, side){
    node.data._branchIndex = branchIndex;
    node.data._side = side;
    node.children?.forEach(c => assignBranch(c, branchIndex, side));
    node._children?.forEach(c => assignBranch(c, branchIndex, side));
  }

  function collapseAll(node){
    if(node.children){
      node._children = node.children;
      node._children.forEach(collapseAll);
      node.children = null;
    }
  }

  function expandFromSaved(node, expandedSet){
    // root always expanded
    if(node.depth === 0 && node._children){
      node.children = node._children;
      node._children = null;
    }
    if(expandedSet.has(node.data.ID) && node._children){
      node.children = node._children;
      node._children = null;
    }
    (node.children || node._children || []).forEach(c => expandFromSaved(c, expandedSet));
  }

  function colorFor(d){
    if(d.depth === 0) return { fill:ROOT_FILL, stroke:ROOT_STROKE };
    const idx = d.data._branchIndex ?? (d.parent ? (d.parent.data._branchIndex||0) : 0);
    const base = BRANCH_BASE[idx % BRANCH_BASE.length];
    const t = Math.min(d.depth / 5, 0.6);
    return {
      fill: d3.interpolateRgb(base, "#ffffff")(t),
      stroke: d3.color(base).darker(0.8)
    };
  }

  function computeExpandedSet(){
    const ids = [];
    root.each(d => {
      if(d.children && d.depth >= 0) ids.push(d.data.ID);
    });
    return ids;
  }

  function saveExpanded(){
    const arr = computeExpandedSet();
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(arr));
    } catch(e) {
      console.warn("Could not save state", e);
    }
  }

  function loadExpanded(){
    try{
      const txt = localStorage.getItem(STORAGE_KEY);
      if(!txt) return null;
      const arr = JSON.parse(txt);
      return new Set(arr);
    }catch(e){
      return null;
    }
  }

  // ============================
  // UPDATE (main render)
  // ============================
  function update(source){
    const layout = d3.tree().nodeSize([VERT_SPACING, 100]);
    const treeData = layout(root);
    const nodes = treeData.descendants();
    const links = treeData.links();

    nodes.forEach(d=>{
      const side = d.data._side ?? (d.parent ? d.parent.data._side||1 : 1);
      d.screenX = d.x;
      d.screenY = d.depth * DEPTH_SPACING * side;
    });

    lastNodes = nodes;
    lastLinks = links;

    // ----- NODES -----
    const nodeSel = nodesLayer.selectAll("g.node").data(nodes, d=>d.data.ID);

    const nodeEnter = nodeSel.enter().append("g")
      .attr("class","node")
      .attr("transform",`translate(${source.y0||0},${source.x0||0})`)
      .style("cursor","pointer")
      .on("click",(e,d)=>{
        if(d.data.PhotoURL){
          const url = d.data.PhotoURL.trim();
          if(url) window.open(url,"_blank","noopener");
        }
      })
      .on("dblclick",(e,d)=>{
        e.stopPropagation();
        if(d.children){
          d._children = d.children;
          d.children = null;
        } else {
          d.children = d._children;
          d._children = null;
        }
        update(d);
        saveExpanded();
      })
      .on("mouseover",(e,d)=>{
        if(d.data.Details){
          tooltip.style("display","block")
                 .html(d.data.Details)
                 .style("left",(e.pageX+10)+"px")
                 .style("top",(e.pageY+10)+"px");
        }
      })
      .on("mousemove",(e)=>{
        tooltip.style("left",(e.pageX+10)+"px")
               .style("top",(e.pageY+10)+"px");
      })
      .on("mouseout",()=>tooltip.style("display","none"));

    // main text (topic)
    nodeEnter.append("text")
      .attr("class","label")
      .attr("x",0).attr("y",0)
      .text(d=>d.data.Name || d.data.ID)
      .style("opacity",0);

    // rect + id label
    nodeEnter.each(function(d){
      const gSel = d3.select(this);
      const textSel = gSel.select("text.label");
      const bb = textSel.node().getBBox();
      const padX = 12, padY = 8;
      const rectW = Math.max(80, bb.width + padX*2);
      const rectH = bb.height + padY*2 + 14; // space for id

      const col = colorFor(d);

      gSel.insert("rect","text.label")
        .attr("x",-rectW/2)
        .attr("y",-rectH/2)
        .attr("width",rectW)
        .attr("height",rectH)
        .style("fill",col.fill)
        .style("stroke",col.stroke)
        .style("opacity",0)
        .attr("rx",10).attr("ry",10);

      // reposition main text
      textSel
        .attr("x",-bb.width/2)
        .attr("y",-2);

      // ID label (node number)
      gSel.append("text")
        .attr("class","id-label")
        .attr("x", -rectW/2 + 6)
        .attr("y", rectH/2 - 6)
        .text(d.data.ID);

      // links: underlined blue text
      if(d.data.PhotoURL && d.data.PhotoURL.trim()){
        textSel
          .style("fill","#0d47a1")
          .style("text-decoration","underline");
      } else if(d.depth === 0){
        textSel.style("fill","#ffffff");
      }

      if(d.depth === 0){
        gSel.select("rect")
          .style("fill",ROOT_FILL)
          .style("stroke",ROOT_STROKE);
      }

      // end node red dot
      const side = d.data._side ?? (d.parent ? d.parent.data._side||1 : 1);
      gSel.append("circle")
        .attr("class","end-dot")
        .attr("r",6)
        .attr("cx", side>=0 ? (rectW/2 + 10) : -(rectW/2 + 10))
        .attr("cy",0)
        .style("opacity",(!d.children && !d._children)?1:0);
    });

    // animate node appearance
    nodeEnter.select("rect")
      .transition().duration(NODE_DUR)
      .style("opacity",1);

    nodeEnter.select("text.label")
      .transition().duration(NODE_DUR)
      .style("opacity",1);

    const nodeMerge = nodeEnter.merge(nodeSel);

    nodeMerge.transition().duration(NODE_DUR)
      .attr("transform",d=>`translate(${d.screenY},${d.screenX})`);

    // update end-dot visibility
    nodeMerge.select("circle.end-dot")
      .transition().duration(NODE_DUR)
      .style("opacity",d=>(!d.children && !d._children)?1:0);

    // exit nodes (shrink + fade)
    nodeSel.exit()
      .transition().duration(NODE_DUR)
      .style("opacity",0)
      .attr("transform",d=>`translate(${source.screenY},${source.screenX}) scale(0.7)`)
      .remove();

    // ----- LINKS -----
    const linkSel = linksLayer.selectAll("path.link").data(links, d=>d.target.data.ID);

    const linkEnter = linkSel.enter().append("path")
      .attr("class","link")
      .attr("d",d=>mindCurve(source,source))
      .style("stroke",d=>{
        const col = colorFor(d.target);
        return col.stroke;
      })
      .style("stroke-dasharray",function(){
        const L = this.getTotalLength ? this.getTotalLength() : 0;
        return `${L} ${L}`;
      })
      .style("stroke-dashoffset",function(){
        const L = this.getTotalLength ? this.getTotalLength() : 0;
        return L;
      });

    linkEnter.merge(linkSel)
      .transition().duration(LINK_DUR)
      .attr("d",d=>mindCurve(d.source,d.target))
      .style("stroke-dashoffset",0);

    linkSel.exit()
      .transition().duration(LINK_DUR)
      .style("opacity",0)
      .remove();

    // save positions for next transition & auto-save state
    nodes.forEach(d => { d.x0 = d.screenX; d.y0 = d.screenY; });
    updateMinimap(nodes, links);
  }

  function mindCurve(s,d){
    const sx = s.screenY, sy = s.screenX;
    const tx = d.screenY, ty = d.screenX;
    const dx = (tx - sx) * 0.55;
    return `M ${sx},${sy} C ${sx+dx},${sy} ${tx-dx},${ty} ${tx},${ty}`;
  }

  // ============================
  // MINI-MAP
  // ============================
  function updateMinimap(nodes, links){
    if(!nodes || !nodes.length) return;
    const miniW = +miniSvg.attr("width") || 220;
    const miniH = +miniSvg.attr("height") || 160;

    const minWX = d3.min(nodes, d=>d.screenY);
    const maxWX = d3.max(nodes, d=>d.screenY);
    const minWY = d3.min(nodes, d=>d.screenX);
    const maxWY = d3.max(nodes, d=>d.screenX);
    const wRange = maxWX - minWX || 1;
    const hRange = maxWY - minWY || 1;

    const scale = 0.85 * Math.min(miniW / wRange, miniH / hRange);
    const offX = (miniW - wRange*scale)/2 - minWX*scale;
    const offY = (miniH - hRange*scale)/2 - minWY*scale;

    function mapX(worldX){ return worldX * scale + offX; }
    function mapY(worldY){ return worldY * scale + offY; }

    // links
    const miniL = miniLinks.selectAll("line").data(links, d=>d.target.data.ID);
    miniL.enter().append("line")
      .merge(miniL)
      .attr("x1",d=>mapX(d.source.screenY))
      .attr("y1",d=>mapY(d.source.screenX))
      .attr("x2",d=>mapX(d.target.screenY))
      .attr("y2",d=>mapY(d.target.screenX))
      .attr("stroke","#cfd8e3")
      .attr("stroke-width",1);
    miniL.exit().remove();

    // nodes
    const miniN = miniNodes.selectAll("circle").data(nodes, d=>d.data.ID);
    miniN.enter().append("circle")
      .merge(miniN)
      .attr("cx",d=>mapX(d.screenY))
      .attr("cy",d=>mapY(d.screenX))
      .attr("r",2.5)
      .attr("fill",d=>colorFor(d).stroke);
    miniN.exit().remove();

    // viewport rectangle from zoom transform
    const t = currentTransform || d3.zoomIdentity;
    const worldX0 = (0 - t.x) / t.k;
    const worldY0 = (0 - t.y) / t.k;
    const worldX1 = (W() - t.x) / t.k;
    const worldY1 = (H() - t.y) / t.k;

    const vx = mapX(worldX0);
    const vy = mapY(worldY0);
    const vw = (worldX1 - worldX0) * scale;
    const vh = (worldY1 - worldY0) * scale;

    miniView
      .attr("x", vx)
      .attr("y", vy)
      .attr("width", Math.max(10, vw))
      .attr("height", Math.max(10, vh));
  }

  // ============================
  // SEARCH & JUMP
  // ============================
  function buildSearch(nodes){
    const items = nodes.map(n => ({
      id: n.data.ID,
      name: n.data.Name,
      node: n
    }));

    searchInput.addEventListener("input", ()=> {
      const q = searchInput.value.trim().toLowerCase();
      if(!q){
        suggestionsBox.style.display="none";
        suggestionsBox.innerHTML="";
        return;
      }
      const matches = items.filter(it =>
        (it.name && it.name.toLowerCase().includes(q)) ||
        (it.id && it.id.toLowerCase().includes(q))
      ).slice(0,20);

      if(matches.length===0){
        suggestionsBox.innerHTML="<div class='suggest-item'>No matches</div>";
        suggestionsBox.style.display="block";
        return;
      }
      suggestionsBox.innerHTML = matches.map(m =>
        `<div class="suggest-item" data-id="${m.id}">
           <strong>${m.name||m.id}</strong><br>
           <span style="font-size:11px;color:#666">${m.id}</span>
         </div>`
      ).join("");
      suggestionsBox.style.display="block";

      suggestionsBox.querySelectorAll(".suggest-item").forEach(el=>{
        el.onclick = ()=>{
          const id = el.getAttribute("data-id");
          const hit = items.find(x=>x.id===id);
          if(hit) focusOn(hit.node);
          suggestionsBox.style.display="none";
        };
      });
    });

    searchInput.addEventListener("keydown", e=>{
      if(e.key==="Enter"){
        e.preventDefault();
        const q = searchInput.value.trim().toLowerCase();
        if(!q) return;
        const hit = items.find(it =>
          (it.name && it.name.toLowerCase().includes(q)) ||
          (it.id && it.id.toLowerCase().includes(q))
        );
        if(hit) focusOn(hit.node);
        suggestionsBox.style.display="none";
      }
      if(e.key==="Escape"){
        suggestionsBox.style.display="none";
      }
    });

    document.addEventListener("click", e=>{
      if(!document.getElementById("searchWrap").contains(e.target)){
        suggestionsBox.style.display="none";
      }
    });
  }

  function focusOn(node){
    // expand ancestors if collapsed
    let cur = node;
    const ancestorsToExpand = [];
    while(cur.parent){
      if(cur.parent._children) ancestorsToExpand.push(cur.parent);
      cur = cur.parent;
    }
    ancestorsToExpand.reverse().forEach(p=>{
      p.children = p._children;
      p._children = null;
    });
    update(node);
    saveExpanded();

    setTimeout(()=>{
      const sel = nodesLayer.selectAll("g.node").filter(d=>d.data.ID===node.data.ID);
      if(sel.empty()) return;
      const bb = sel.node().getBBox();
      const cx = bb.x + bb.width/2;
      const cy = bb.y + bb.height/2;
      const scale = Math.min(1.8,Math.max(0.6, Math.min(W()/(bb.width*6), H()/(bb.height*6))));
      const tx = (W()/2) - cx*scale;
      const ty = (H()/2) - cy*scale;
      svg.transition().duration(400).call(zoom.transform,
        d3.zoomIdentity.translate(tx,ty).scale(scale)
      );
      sel.select("rect").classed("highlight",true);
      setTimeout(()=>sel.select("rect").classed("highlight",false),1200);
    }, NODE_DUR+40);
  }

  // ============================
  // AUTO-FIT ONCE
  // ============================
  function fitToContent(){
    try{
      const full = nodesLayer.node().getBBox();
      const margin = 80;
      const w = W(), h = H();
      const scale = Math.min((w - margin)/full.width, (h - margin)/full.height);
      const s = Math.max(0.3, Math.min(scale,1.5));
      const tx = (w - full.width*s)/2 - full.x*s;
      const ty = (h - full.height*s)/2 - full.y*s;
      svg.call(zoom.transform, d3.zoomIdentity.translate(tx,ty).scale(s));
    }catch(e){
      console.warn("fit error", e);
    }
  }

  // ============================
  // DOWNLOAD SVG & PNG
  // ============================
  document.getElementById("btnSvg").onclick = ()=> downloadSVG();
  document.getElementById("btnPng").onclick = ()=> downloadPNG();

  function downloadSVG(){
    const clone = svg.node().cloneNode(true);
    clone.removeAttribute("style");
    const outer = document.createElementNS("http://www.w3.org/2000/svg","svg");
    outer.setAttribute("xmlns","http://www.w3.org/2000/svg");
    outer.setAttribute("width", W());
    outer.setAttribute("height", H());
    outer.appendChild(clone);
    const serializer = new XMLSerializer();
    const source = serializer.serializeToString(outer);
    const blob = new Blob([source], {type:"image/svg+xml;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "open_science_open_access_mindmap.svg";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  function downloadPNG(){
    const xml = new XMLSerializer().serializeToString(svg.node());
    const svg64 = btoa(unescape(encodeURIComponent(xml)));
    const image64 = "data:image/svg+xml;base64," + svg64;

    const image = new Image();
    image.onload = function(){
      const canvas = document.createElement("canvas");
      canvas.width = W()*2;
      canvas.height = H()*2;
      const ctx = canvas.getContext("2d");
      ctx.setTransform(2,0,0,2,0,0);
      ctx.fillStyle="#ffffff";
      ctx.fillRect(0,0,W(),H());
      ctx.drawImage(image,0,0);
      const png = canvas.toDataURL("image/png");
      const a = document.createElement("a");
      a.href = png;
      a.download = "open_science_open_access_mindmap.png";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    };
    image.src = image64;
  }

}); // end CSV load

</script>
</body>
</html>
