<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Open Access and Open Science Mindmap</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
  body {
    margin: 0;
    font-family: "Segoe UI", Arial, sans-serif;
    background: #f5f7fb;
  }

  #container {
    width: 100%;
    height: 100vh;
    display: flex;
    flex-direction: column;
  }

  #title {
    flex: 0 0 auto;
    background: #08306b;
    color: #fff;
    text-align: center;
    padding: 10px 16px;
    font-size: 20px;
    font-weight: 600;
  }

  #canvas {
    flex: 1 1 auto;
    position: relative;
  }

  svg {
    width: 100%;
    height: 100%;
    display: block;
    cursor: grab;
  }

  .tooltip {
    position: absolute;
    padding: 6px 8px;
    background: #fff;
    border: 1px solid #ccc;
    border-radius: 6px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.15);
    font-size: 12px;
    max-width: 280px;
    pointer-events: none;
    display: none;
    z-index: 20;
  }

  .node rect {
    rx: 10;
    ry: 10;
    stroke-width: 1.5px;
    fill: #ffffff;
    stroke: #90a4ae;
    filter: drop-shadow(0 1px 2px rgba(0,0,0,0.15));
  }

  .node text {
    font-size: 14px;
    pointer-events: none;
    fill: #102a43;
  }

  .node.link-node text {
    fill: #0b63b6;
    text-decoration: underline;
  }

  .link {
    fill: none;
    stroke-width: 2px;
    stroke: #cfd8e3;
    opacity: 0.95;
  }

  .end-dot {
    fill: #d32f2f;
    stroke: #b00000;
    stroke-width: 1.5;
  }
</style>
</head>
<body>
<div id="container">
  <div id="title">Open Access and Open Science</div>
  <div id="canvas">
    <div id="tooltip" class="tooltip"></div>
    <svg>
      <g id="links-layer"></g>
      <g id="nodes-layer"></g>
    </svg>
  </div>
</div>

<script>
// === CONFIG ===
const CSV_URL = "https://raw.githubusercontent.com/tkguha/oa/main/oaos.csv";

// layout spacing
const VERT_SPACING   = 40;   // base vertical spacing (before anti-overlap)
const DEPTH_SPACING  = 140;  // horizontal distance between depth levels
const MIN_VERTICAL_GAP = 55; // minimum vertical gap between boxes in same depth

// branch colors (balanced layout: half left, half right)
const BRANCH_COLORS = [
  "#1976d2", // branch 0
  "#2e7d32", // branch 1
  "#fb8c00", // branch 2
  "#6a1b9a"  // branch 3
];

// === SETUP SVG / LAYERS / ZOOM ===
const svg   = d3.select("svg");
const linkLayer = d3.select("#links-layer");
const nodeLayer = d3.select("#nodes-layer");
const tooltip = d3.select("#tooltip");

const zoom = d3.zoom()
  .scaleExtent([0.25, 3])
  .on("zoom", (event) => {
    linkLayer.attr("transform", event.transform);
    nodeLayer.attr("transform", event.transform);
  });

svg.call(zoom);

// === LOAD CSV AND BUILD HIERARCHY ===
d3.csv(CSV_URL).then(data => {
  // normalize
  data.forEach(d => {
    d.node_id  = (d.node_id  || "").trim();
    d.parent_id= (d.parent_id|| "").trim();
    d.topic    = (d.topic    || "").trim();
    d.links    = (d.links    || "").trim();
    d.children = [];
  });

  // map by id
  const byId = new Map();
  data.forEach(d => { if (d.node_id) byId.set(d.node_id, d); });

  // find root (no parent_id)
  let rootData = data.find(d => !d.parent_id);
  if (!rootData) rootData = data[0]; // fallback

  // build children arrays
  data.forEach(d => {
    if (d.parent_id && byId.has(d.parent_id)) {
      byId.get(d.parent_id).children.push(d);
    }
  });

  const root = d3.hierarchy(rootData, d => d.children && d.children.length ? d.children : null);
  root.x0 = 0;
  root.y0 = 0;

  // Assign balanced sides & branch index for first-level children
  if (root.children && root.children.length > 0) {
    const mid = Math.ceil(root.children.length / 2); // half left, half right
    root.children.forEach((c, i) => {
      const side = (i < mid) ? -1 : 1; // left (negative y), right (positive y)
      const branchIndex = i % BRANCH_COLORS.length;
      assignSideAndBranch(c, side, branchIndex);
    });
  }

  // collapse all children initially
  root.children && root.children.forEach(collapse);
  // optionally open first level
  root.children && root.children.forEach(c => { c.children = c._children; c._children = null; });

  update(root);
  setTimeout(autoFit, 600);

  function assignSideAndBranch(node, side, branchIndex) {
    node.data._side = side;
    node.data._branch = branchIndex;
    if (node.children) node.children.forEach(c => assignSideAndBranch(c, side, branchIndex));
    if (node._children) node._children.forEach(c => assignSideAndBranch(c, side, branchIndex));
  }

  function collapse(node){
    if (node.children) {
      node._children = node.children;
      node._children.forEach(collapse);
      node.children = null;
    }
  }

  // main redraw function
  function update(source) {
    const treeLayout = d3.tree().nodeSize([VERT_SPACING, 1]);
    treeLayout(root);

    const nodes = root.descendants();
    const links = root.links();

    // set x,y from tree; then adjust y by side, and run anti-overlap on x
    nodes.forEach(d => {
      const side = d.data._side !== undefined ? d.data._side
                  : (d.parent ? d.parent.data._side || 1 : 1);
      d.y = d.depth * DEPTH_SPACING * side;
      d.x = d.x; // from layout
    });

    // physics-ish anti-overlap per depth (1D vertical relaxation)
    const byDepth = d3.group(nodes, d => d.depth);
    byDepth.forEach(group => {
      group.sort((a,b) => a.x - b.x);
      for (let i = 1; i < group.length; i++) {
        const prev = group[i-1];
        const curr = group[i];
        const gap = curr.x - prev.x;
        if (gap < MIN_VERTICAL_GAP) {
          const shift = MIN_VERTICAL_GAP - gap;
          curr.x += shift;
          // also shift all deeper nodes in same subtree by same amount
          shiftSubtree(curr, shift);
        }
      }
    });

    function shiftSubtree(node, deltaX) {
      node.descendants().forEach(n => { n.x += deltaX; });
    }

    // ================= NODES =================
    const nodeSel = nodeLayer.selectAll("g.node")
      .data(nodes, d => d.data.node_id);

    const nodeEnter = nodeSel.enter()
      .append("g")
      .attr("class","node")
      .attr("transform", d => `translate(${source.y0 || 0},${source.x0 || 0})`)
      .style("cursor","pointer")
      .on("click", (event, d) => {
        if (d.data.links) {
          window.open(d.data.links, "_blank", "noopener");
        }
      })
      .on("dblclick", (event, d) => {
        event.stopPropagation();
        if (d.children) {
          d._children = d.children;
          d.children = null;
        } else {
          d.children = d._children;
          d._children = null;
        }
        update(d);
      });

    // text first (centered), then rect size based on bbox
    nodeEnter.append("text")
      .attr("dy","0.35em")
      .attr("text-anchor","middle")
      .text(d => d.data.topic || d.data.node_id || "(no label)");

    nodeEnter.each(function(d){
      const sel = d3.select(this);
      const textNode = sel.select("text").node();
      const bb = textNode.getBBox();
      const padX = 12, padY = 8;
      const w = bb.width + padX*2;
      const h = bb.height + padY*2;

      const branchIndex = d.data._branch ?? (d.parent ? d.parent.data._branch ?? 0 : 0);
      const baseCol = BRANCH_COLORS[branchIndex % BRANCH_COLORS.length];
      const depthFactor = Math.min(d.depth / 4, 0.6);
      const fillCol = d.depth === 0 ? "#08306b" : d3.interpolateRgb(baseCol, "#ffffff")(depthFactor);
      const strokeCol = d.depth === 0 ? "#08306b" : d3.color(baseCol).darker(0.7);

      sel.insert("rect","text")
        .attr("x", -w/2)
        .attr("y", -h/2)
        .attr("width", w)
        .attr("height", h)
        .attr("rx", 10)
        .attr("ry", 10)
        .style("fill", fillCol)
        .style("stroke", strokeCol);

      if (d.depth === 0) {
        sel.select("text").style("fill","#ffffff").style("font-weight","700");
      }

      // mark link nodes
      if (d.data.links) {
        sel.classed("link-node", true);
      }

      // end-of-branch red dot
      const side = d.data._side !== undefined ? d.data._side
                  : (d.parent ? d.parent.data._side || 1 : 1);
      const dotX = side >= 0 ? (w / 2 + 10) : -(w / 2 + 10);
      const isLeaf = !d.children && !d._children;

      if (isLeaf) {
        sel.append("circle")
          .attr("class","end-dot")
          .attr("r",5)
          .attr("cx", dotX)
          .attr("cy", 0);
      }
    });

    // transition nodes to new positions
    const nodeMerge = nodeEnter.merge(nodeSel);

    nodeMerge.transition().duration(200)
      .attr("transform", d => `translate(${d.y},${d.x})`);

    nodeSel.exit()
      .transition().duration(150)
      .style("opacity",0)
      .remove();

    // ================= LINKS =================
    const linkSel = linkLayer.selectAll("path.link")
      .data(links, d => d.target.data.node_id);

    const linkEnter = linkSel.enter()
      .append("path")
      .attr("class","link")
      .attr("d", d => linkCurve(source, source));

    linkEnter.merge(linkSel)
      .transition().duration(200)
      .attr("d", d => linkCurve(d.source, d.target));

    linkSel.exit()
      .transition().duration(150)
      .style("opacity",0)
      .remove();

    // save positions
    nodes.forEach(d => { d.x0 = d.x; d.y0 = d.y; });
  }

  // Mindmap-style curve
  function linkCurve(s, d) {
    const x1 = s.x, y1 = s.y;
    const x2 = d.x, y2 = d.y;
    const k = 0.55;
    const cx1 = y1 + (y2 - y1) * k;
    const cx2 = y2 - (y2 - y1) * k;
    return `M${y1},${x1} C${cx1},${x1} ${cx2},${x2} ${y2},${x2}`;
  }

  // auto-fit whole diagram once at load
  function autoFit() {
    const bboxNodes = nodeLayer.node().getBBox();
    const margin = 60;
    const width = svg.node().clientWidth;
    const height = svg.node().clientHeight;

    const scale = Math.min(
      (width  - margin) / bboxNodes.width,
      (height - margin) / bboxNodes.height
    );

    const s = Math.max(0.25, Math.min(scale, 1.8));
    const tx = (width  - bboxNodes.width  * s) / 2 - bboxNodes.x * s;
    const ty = (height - bboxNodes.height * s) / 2 - bboxNodes.y * s;

    svg.call(
      zoom.transform,
      d3.zoomIdentity.translate(tx, ty).scale(s)
    );
  }

}).catch(err => {
  console.error("Error loading CSV:", err);
});
</script>
</body>
</html>
