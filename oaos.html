<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Open Access and Open Science Mindmap</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
  :root{
    --bg:#f4f6fa;
    --header-bg:#0b63b6;
    --font:"Segoe UI",Roboto,Arial,sans-serif;
  }
  html,body{
    margin:0;
    height:100%;
    font-family:var(--font);
    background:var(--bg);
  }

  header{
    background:var(--header-bg);
    color:#fff;
    padding:14px 18px;
    text-align:center;
    font-size:20px;
    font-weight:700;
  }

  #canvas{
    position:relative;
    height:calc(100vh - 56px);
    overflow:hidden;
  }

  svg{
    width:100%;
    height:100%;
    cursor:grab;
    display:block;
  }

  #searchBox{
    position:absolute;
    left:50%;
    top:10px;
    transform:translateX(-50%);
    width:320px;
    padding:8px 10px;
    border-radius:8px;
    border:1px solid #cfd8e3;
    box-shadow:0 1px 4px rgba(0,0,0,0.12);
    z-index:20;
  }

  #credits{
    position:absolute;
    right:14px;
    top:10px;
    max-width:260px;
    background:#ffffff;
    border-radius:8px;
    padding:8px 10px;
    box-shadow:0 2px 8px rgba(0,0,0,0.12);
    font-size:12px;
    line-height:1.4;
    z-index:21;
  }
  #credits b{display:block;margin-bottom:4px;}

  #tooltip{
    position:absolute;
    padding:8px 10px;
    background:rgba(0,0,0,0.85);
    color:#fff;
    font-size:13px;
    border-radius:6px;
    max-width:320px;
    display:none;
    z-index:30;
    pointer-events:none;
  }

  .node text{
    font-size:14px;
    pointer-events:none;
  }
  .node rect{
    rx:10; ry:10;
    stroke-width:2;
    filter:drop-shadow(0 1px 2px rgba(0,0,0,0.16));
  }
  .node-number{
    font-size:11px;
    font-weight:600;
    fill:#555;
  }

  .link{
    fill:none;
    stroke-width:2px;
    opacity:0.9;
  }

  .end-dot{
    fill:#d32f2f;
    stroke:#b00000;
    stroke-width:1.5;
  }

  .highlight rect{
    stroke:#ffeb3b !important;
    stroke-width:4px !important;
  }

  .linked text{
    text-decoration:underline;
    fill:#0b63b6;
  }
</style>
</head>

<body>
<header>Open Access and Open Science</header>

<div id="canvas">
  <input id="searchBox" type="text" placeholder="Search node..." />
  <div id="credits">
    <b>Credits</b>
    Dr. Tamal Kumar Guha,<br/>
    Librarian, IIT Guwahati<br/><br/>
    Presented at a Workshop on 22nd Nov. 2025 at NEHU, DLISc<br/>
    <i>Workshop Title:</i> Research Support Services: Role of Libraries and
    Library Professionals in the Digital Landscape
  </div>
  <div id="tooltip"></div>
  <svg>
    <g id="links-layer"></g>
    <g id="nodes-layer"></g>
  </svg>
</div>

<script>
// ================== CONFIG ==================
const CSV_URL   = "https://raw.githubusercontent.com/tkguha/oa/main/oaos.csv";
const LEFT_COUNT = 2;           // first 2 root branches on left
const VERT_SPACING  = 50;
const DEPTH_SPACING = 160;
const MIN_SEP       = 40;
const NODE_DUR      = 300;
const LINK_DUR      = 300;

const BRANCH_BASE = [
  "#1976d2",
  "#2e7d32",
  "#fb8c00",
  "#6a1b9a"
];
const ROOT_FILL   = "#08306b";
const ROOT_STROKE = "#08306b";

// ================== SVG & ZOOM ==================
const svg        = d3.select("svg");
const linkLayer  = d3.select("#links-layer");
const nodeLayer  = d3.select("#nodes-layer");
const tooltip    = d3.select("#tooltip");
const searchBox  = document.getElementById("searchBox");

const zoom = d3.zoom()
  .scaleExtent([0.25, 3])
  .on("zoom", (event) => {
    linkLayer.attr("transform", event.transform);
    nodeLayer.attr("transform", event.transform);
  });

svg.call(zoom);

const getWidth  = () => svg.node().clientWidth;
const getHeight = () => svg.node().clientHeight;

// ================== LOAD CSV ==================
d3.csv("https://raw.githubusercontent.com/tkguha/oa/main/oaos.csv").then(raw => {

  // normalise CSV
  const rows = raw.map(r => ({
    id:       (r.node_id   || "").trim(),
    parentId: (r.parent_id || "").trim(),
    level:    +r.level || 0,
    name:     (r.topic || "").trim(),
    link:     (r.links || "").trim()
  })).filter(r => r.id); // ignore any empty rows

  // build map & children
  const byId = new Map();
  rows.forEach(r => byId.set(r.id, {...r, children: []}));

  let rootData = null;
  byId.forEach(node => {
    if (!node.parentId) {
      rootData = node;
    } else if (byId.has(node.parentId)) {
      byId.get(node.parentId).children.push(node);
    }
  });

  if (!rootData) {
    alert("No root node found (row with empty parent_id).");
    return;
  }

  const root = d3.hierarchy(rootData, d => d.children && d.children.length ? d.children : null);

  // sequential numbering
  root.descendants().forEach((d, i) => { d.data.seq = i + 1; });

  // assign branch + side from first-level children
  if (root.children) {
    root.children.forEach((c, i) => {
      const side = i < LEFT_COUNT ? -1 : 1;
      const branchIndex = i % BRANCH_BASE.length;
      assignBranchAndSide(c, branchIndex, side);
    });
  }

  function assignBranchAndSide(node, branch, side){
    node.data.branch = branch;
    node.data.side   = side;
    node.children?.forEach(ch => assignBranchAndSide(ch, branch, side));
  }

  // expand everything, then collapse below depth 2 (keep first 2 levels open)
  root.descendants().forEach(d => {
    if (d.children || d._children) {
      d.children = d.children || d._children;
      d._children = null;
    }
  });
  root.descendants().forEach(d => {
    if (d.depth > 2 && d.children) {
      d._children = d.children;
      d.children = null;
    }
  });

  const treeLayout = d3.tree().nodeSize([VERT_SPACING, 100]);

  update(root);
  setTimeout(autoFit, 600);

  // =============== UPDATE (DRAW) ===============
  function update(source){
    treeLayout(root);
    const nodes = root.descendants();
    const links = root.links();

    // balanced left/right
    nodes.forEach(d => {
      const side = d.data.side !== undefined
        ? d.data.side
        : (d.parent ? d.parent.data.side || 1 : 1);
      d.screenX = d.x;
      d.screenY = d.depth * DEPTH_SPACING * side;
    });

    // anti-overlap per depth
    const depthGroups = d3.group(nodes, d => d.depth);
    depthGroups.forEach(group => {
      group.sort((a,b) => a.screenX - b.screenX);
      for (let i = 1; i < group.length; i++) {
        const prev = group[i-1];
        const curr = group[i];
        if (curr.screenX - prev.screenX < MIN_SEP) {
          const shift = MIN_SEP - (curr.screenX - prev.screenX);
          curr.screenX += shift;
        }
      }
    });

    // ----- NODES -----
    const nodeSel = nodeLayer.selectAll("g.node")
      .data(nodes, d => d.data.id);

    const nodeEnter = nodeSel.enter()
      .append("g")
      .attr("class","node")
      .attr("transform", `translate(${source.y0 || 0},${source.x0 || 0})`)
      .style("cursor","pointer")
      .on("click", (event, d) => {
        if (d.data.link) window.open(d.data.link, "_blank", "noopener");
      })
      .on("dblclick", (event, d) => {
        event.stopPropagation();
        if (d.children) {
          d._children = d.children;
          d.children = null;
        } else {
          d.children = d._children;
          d._children = null;
        }
        update(d);
      });

    nodeEnter.append("rect")
      .attr("width",40)
      .attr("height",20)
      .attr("x",-20)
      .attr("y",-10)
      .style("opacity",0);

    nodeEnter.append("text")
      .attr("class","node-number")
      .attr("text-anchor","end")
      .attr("x",-6)
      .attr("y",-2)
      .text(d => d.data.seq + ".");

    nodeEnter.append("text")
      .attr("class","label-text")
      .attr("text-anchor","start")
      .attr("x",0)
      .attr("y",4)
      .text(d => d.data.name);

    nodeEnter.each(function(d){
      const gSel = d3.select(this);
      const num  = gSel.select(".node-number").node().getBBox();
      const lab  = gSel.select(".label-text").node().getBBox();
      const padX = 10, padY = 6;
      const width  = num.width + lab.width + padX*2 + 6;
      const height = Math.max(num.height, lab.height) + padY*2;

      const {fill,stroke} = colorFor(d);

      gSel.select("rect")
        .attr("x", -width/2)
        .attr("y", -height/2)
        .attr("width", width)
        .attr("height", height)
        .style("fill", d.depth===0 ? ROOT_FILL : fill)
        .style("stroke", d.depth===0 ? ROOT_STROKE : stroke);

      const offsetLeft = -width/2 + padX;
      gSel.select(".node-number")
        .attr("x", offsetLeft + num.width)
        .attr("y", 4 - height/2 + padY);

      gSel.select(".label-text")
        .attr("x", offsetLeft + num.width + 6)
        .attr("y", 4 - height/2 + padY);

      if (d.depth === 0) {
        gSel.selectAll("text")
          .style("fill","#ffffff")
          .style("font-weight","600");
      } else if (d.data.link) {
        gSel.classed("linked", true);
      }
    });

    const nodeMerge = nodeEnter.merge(nodeSel);

    nodeMerge.transition().duration(NODE_DUR)
      .attr("transform", d => `translate(${d.screenY},${d.screenX})`);

    nodeSel.exit()
      .transition().duration(NODE_DUR)
      .style("opacity",0)
      .remove();

    // red dots on leaves
    nodeMerge.each(function(d){
      const gSel = d3.select(this);
      gSel.select(".end-dot").remove();
      if (!d.children && !d._children) {
        const rect = gSel.select("rect").node().getBBox();
        const side = d.data.side ?? (d.parent ? d.parent.data.side || 1 : 1);
        gSel.append("circle")
          .attr("class","end-dot")
          .attr("r",5)
          .attr("cx", side >= 0 ? rect.width/2 + rect.x + 10 : rect.x - 10)
          .attr("cy",0);
      }
    });

    // ----- LINKS -----
    const linkSel = linkLayer.selectAll("path.link")
      .data(links, d => d.target.data.id);

    const linkEnter = linkSel.enter()
      .append("path")
      .attr("class","link")
      .attr("d", d => linkPath(source, source));

    linkEnter.merge(linkSel)
      .style("stroke", d => colorFor(d.target).stroke)
      .transition().duration(LINK_DUR)
      .attr("d", d => linkPath(d.source, d.target));

    linkSel.exit()
      .transition().duration(LINK_DUR)
      .style("opacity",0)
      .remove();

    nodes.forEach(d => { d.x0 = d.screenX; d.y0 = d.screenY; });
  }

  function linkPath(s, d){
    const sx = s.screenY ?? s.y0;
    const sy = s.screenX ?? s.x0;
    const tx = d.screenY ?? d.y0;
    const ty = d.screenX ?? d.x0;
    const dx = (tx - sx) * 0.55;
    return `M${sx},${sy} C${sx+dx},${sy} ${tx-dx},${ty} ${tx},${ty}`;
  }

  function colorFor(d){
    if (d.depth === 0) return {fill:ROOT_FILL, stroke:ROOT_STROKE};
    const idx = d.data.branch ?? 0;
    const base = BRANCH_BASE[idx % BRANCH_BASE.length];
    const t = Math.min(d.depth/5, 0.6);
    return {
      fill:   d3.interpolateRgb(base,"#ffffff")(t),
      stroke: d3.color(base).darker(0.8)
    };
  }

  function autoFit(){
    try{
      const box = nodeLayer.node().getBBox();
      const margin = 80;
      const w = getWidth();
      const h = getHeight();
      const scale = Math.min((w-margin)/box.width, (h-margin)/box.height);
      const s = Math.max(0.25, Math.min(scale, 1.6));
      const tx = (w - box.width*s)/2 - box.x*s;
      const ty = (h - box.height*s)/2 - box.y*s;
      svg.call(zoom.transform, d3.zoomIdentity.translate(tx,ty).scale(s));
    }catch(e){
      console.warn("autoFit error", e);
    }
  }

  // SEARCH
  searchBox.addEventListener("input", () => {
    const q = searchBox.value.trim().toLowerCase();
    const nodes = nodeLayer.selectAll("g.node");
    nodes.classed("highlight", false);
    if (!q) return;

    const matches = nodes.filter(d =>
      (d.data.name || "").toLowerCase().includes(q)
    );

    matches.classed("highlight", true);

    const first = matches.datum();
    if (first) {
      const n = nodes.filter(d => d.data.id === first.data.id).node();
      if (!n) return;
      const box = n.getBBox();
      const cx = box.x + box.width/2;
      const cy = box.y + box.height/2;
      const w = getWidth(), h = getHeight();
      const scale = Math.min(1.6, Math.max(0.6,
        Math.min(w/(box.width*6), h/(box.height*6))
      ));
      const tx = w/2 - cx*scale;
      const ty = h/2 - cy*scale;
      svg.transition().duration(400)
         .call(zoom.transform, d3.zoomIdentity.translate(tx,ty).scale(scale));
    }
  });

}); // end csv load
</script>
</body>
</html>
