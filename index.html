<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Family Tree â€” Interactive</title>

  <!-- Force HTTPS -->
  <script>
    if (location.protocol !== 'https:') {
      location.replace(`https:${location.href.substring(location.protocol.length)}`);
    }
  </script>

  <script src="https://d3js.org/d3.v7.min.js"></script>

  <style>
    :root {
      --blue: #1976d2;
      --light: #f8fafc;
      --card: #e3f2fd;
      --text: #111;
    }
    html,body { height:100%; margin:0; padding:0; font-family: "Segoe UI", Arial, sans-serif; background: var(--light); }
    header {
      background: var(--blue);
      color: #fff;
      padding:12px 18px;
      font-weight:600;
      font-size:18px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.12);
      position: relative;
      z-index: 3;
    }

    /* DOWNLOAD tab: placed below header (not covering it) */
    #download-tab {
      position: fixed;
      top: 68px;              /* below header */
      left: 18px;
      background: var(--blue);
      color: white;
      padding: 8px 14px;
      border-radius: 12px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.12);
      font-weight: 600;
      cursor: pointer;
      z-index: 20;
      text-decoration: none;
    }

    #container { position: relative; height: calc(100vh - 68px); }
    svg { width: 100%; height: 100%; cursor: grab; display:block; }
    .link { fill: none; stroke: #bbb; stroke-width: 2px; }
    .node rect { fill: var(--card); stroke: var(--blue); stroke-width:2px; rx:10; ry:10; }
    .node text { font-size: 14px; fill: var(--text); pointer-events: none; }
    .img-icon {
      font-size: 14px;
      cursor: pointer;
      user-select: none;
    }
    .img-preview {
      pointer-events: auto;
      cursor: pointer;
      display:block;
      max-width:100%;
      height:auto;
      border-radius:6px;
    }
    .preview-box {
      box-shadow: 0 6px 18px rgba(0,0,0,0.25);
      border-radius: 6px;
      overflow: hidden;
      background: #fff;
      border: 1px solid rgba(0,0,0,0.06);
    }
    /* small mobile tweaks */
    @media (max-width:700px) {
      .node text { font-size: 12px; }
    }
  </style>
</head>
<body>
  <header>Distortions in Open Access (OA) and impact on Open Educational Resources (OER)</header>

  <!-- Download tab: opens direct download in new tab -->
  <a id="download-tab" href="#" target="_blank" rel="noopener">DOWNLOAD</a>

  <div id="container">
    <svg></svg>
  </div>

<script>
// ---------- CONFIG ----------
const csvUrl = "https://docs.google.com/spreadsheets/d/e/2PACX-1vQbYH3fZ0Fkz4Co5QtSCoZzkWku4jurdda6ttNrWKbJXG94odN5X0hSL06CfaHKREYJ7H8aa8PQmWOx/pub?output=csv";
// Drive file to download when "DOWNLOAD" clicked (kept as you requested earlier)
const downloadDriveShareLink = "https://drive.google.com/file/d/1uOaf9uWl8KKw1KT5l3AbNvvaz7Ckh2lL/view?usp=sharing";
// Image display size selection (IMG-L => 600px)
const IMAGE_WIDTH = 600;
// ----------------------------

// Helpers: convert Drive share -> view/download, convert GitHub blob -> raw
function driveFileIdFromLink(link) {
  const m = link && link.match(/\/d\/([a-zA-Z0-9_-]+)/);
  return m ? m[1] : null;
}
function driveViewUrl(fileId) {
  return `https://drive.google.com/uc?export=view&id=${fileId}`;
}
function driveDownloadUrl(fileId) {
  return `https://drive.google.com/uc?export=download&id=${fileId}`;
}
function githubRawFromBlob(link) {
  // convert https://github.com/user/repo/blob/branch/path -> https://raw.githubusercontent.com/user/repo/branch/path
  if (!link) return link;
  const m = link.match(/^https:\/\/github\.com\/([^\/]+)\/([^\/]+)\/blob\/([^\/]+)\/(.+)$/);
  if (m) {
    return `https://raw.githubusercontent.com/${m[1]}/${m[2]}/${m[3]}/${m[4]}`;
  }
  return link;
}

// Set DOWNLOAD button href (prefer direct download)
const dlId = driveFileIdFromLink(downloadDriveShareLink);
if (dlId) {
  document.getElementById("download-tab").href = driveDownloadUrl(dlId);
} else {
  document.getElementById("download-tab").href = downloadDriveShareLink;
}

// Setup SVG and group
const svg = d3.select("svg");
const container = d3.select("#container");
const g = svg.append("g");

// pan & zoom
const zoom = d3.zoom().scaleExtent([0.3, 3]).on("zoom", (event) => g.attr("transform", event.transform));
svg.call(zoom);

// Horizontal tree layout (left -> right)
const tree = d3.tree().nodeSize([100, 220]); // [vertical spacing, horizontal spacing]
const duration = 450;
let rootNode;
let nodeIndex = 0;

// track open preview (only one at a time)
let openPreviewId = null;

d3.csv(csvUrl).then(rows => {
  // map rows by ID
  const map = {};
  rows.forEach(r => {
    const id = (r.ID || "").toString().trim();
    map[id] = {
      ID: id,
      Name: (r.Name || "").toString().trim(),
      ParentID: (r.ParentID || "").toString().trim(),
      PhotoURL: (r.PhotoURL || "").toString().trim(),
      Details: (r.Details || "").toString().trim(),
      children: []
    };
  });

  // build tree relationships
  let rootData = null;
  Object.values(map).forEach(n => {
    if (n.ParentID && map[n.ParentID]) {
      map[n.ParentID].children.push(n);
    } else if (!rootData) {
      rootData = n;
    }
  });
  if (!rootData) rootData = Object.values(map)[0];

  // make d3.hierarchy
  const root = d3.hierarchy(rootData, d => d.children && d.children.length ? d.children : null);
  root.x0 = 0; root.y0 = 0;
  if (root.children) root.children.forEach(collapse);
  rootNode = root;

  update(rootNode);

  // initial zoom/pan: center top-left-ish area
  const initialScale = 0.8;
  const initialX = 80;
  const initialY = 40;
  svg.call(zoom.transform, d3.zoomIdentity.translate(initialX, initialY).scale(initialScale));
});

// collapse helper
function collapse(d) {
  if (d.children) {
    d._children = d.children;
    d._children.forEach(collapse);
    d.children = null;
  }
}

function update(source) {
  const treeData = tree(rootNode);
  const nodes = treeData.descendants();
  const links = treeData.links();

  // set positions for horizontal layout: x = depth spacing? for d3.tree for left->right we use x,y swapped
  // keep the default: nodes have x (vertical), y (horizontal). We want left->right so treat y as horizontal.
  nodes.forEach(d => d.y = d.depth * 220);

  // NODES
  const node = g.selectAll("g.node").data(nodes, d => d.data.ID);

  // ENTER
  const nodeEnter = node.enter().append("g")
    .attr("class", "node")
    .attr("transform", d => `translate(${source.x0 || 0},${source.y0 || 0})`)
    .on("click", (event, d) => {
      // clicking node toggles children
      if (d.children) { d._children = d.children; d.children = null; }
      else { d.children = d._children; d._children = null; }
      // hide previews to avoid orphaned boxes
      hidePreview();
      update(d);
    });

  // TEXT
  nodeEnter.append("text")
    .attr("dy", "0.35em")
    .attr("text-anchor", "middle")
    .text(d => d.data.Name);

  // After rendering text, measure bbox and insert rect
  nodeEnter.each(function(d) {
    const thisG = d3.select(this);
    const textEl = thisG.select("text").node();
    const bbox = textEl.getBBox();
    const padX = 12, padY = 6;
    const rectW = bbox.width + padX*2;
    const rectH = bbox.height + padY*2;

    thisG.insert("rect", "text")
      .attr("x", -rectW/2)
      .attr("y", -rectH/2)
      .attr("width", rectW)
      .attr("height", rectH)
      .attr("rx", 10).attr("ry", 10)
      .style("fill", "#e3f2fd")
      .style("stroke", "#1976d2")
      .style("stroke-width", 2);

    // If a PhotoURL exists, add a small camera icon to the right of the rect
    if (d.data.PhotoURL) {
      const iconX = rectW/2 + 12;
      thisG.append("text")
        .attr("class", "img-icon")
        .attr("x", iconX)
        .attr("dy", "0.35em")
        .text("ðŸ“·")
        .on("click", (event, nodeDatum) => {
          // don't trigger node click
          event.stopPropagation();
          togglePreview(nodeDatum);
        })
        .append("title")
        .text("Open image (click to toggle). Click image to collapse.");
    }
  });

  // UPDATE (position)
  const nodeUpdate = nodeEnter.merge(node);
  nodeUpdate.transition().duration(duration).attr("transform", d => `translate(${d.x},${d.y})`);

  // EXIT
  const nodeExit = node.exit().transition().duration(duration)
    .attr("transform", d => `translate(${source.x},${source.y})`).remove();

  // LINKS
  const link = g.selectAll("path.link").data(links, d => d.target.data.ID);

  const linkEnter = link.enter().insert("path", "g")
    .attr("class", "link")
    .attr("d", d => {
      const o = { x: source.x0 || 0, y: source.y0 || 0 };
      return horizontalDiagonal(o, o);
    });

  linkEnter.merge(link).transition().duration(duration).attr("d", d => horizontalDiagonal(d.source, d.target));
  link.exit().transition().duration(duration).remove();

  // save positions for transitions
  nodes.forEach(d => { d.x0 = d.x; d.y0 = d.y; });
}

// diagonal for left->right (curved)
function horizontalDiagonal(s, d) {
  // s: source, d: target
  return `M ${s.x} ${s.y}
          C ${ (s.x + d.x)/2 } ${s.y},
            ${ (s.x + d.x)/2 } ${d.y},
            ${d.x} ${d.y}`;
}

// ---------- PREVIEW HANDLING ----------
function hidePreview() {
  g.selectAll("g.img-preview-group").remove();
  openPreviewId = null;
}

function togglePreview(nodeDatum) {
  // if same preview open, close it
  if (openPreviewId === nodeDatum.data.ID) {
    hidePreview();
    return;
  }
  // else close existing and open new
  hidePreview();
  showPreview(nodeDatum);
}

function showPreview(d) {
  // compute image URL: handle GitHub blob -> raw, handle Drive share link -> uc?export=view
  let raw = d.data.PhotoURL || "";
  if (!raw) return;
  const ghRaw = githubRawFromBlob(raw);
  if (ghRaw !== raw) raw = ghRaw;
  // also handle drive share link
  const driveId = driveFileIdFromLink(raw);
  if (driveId) raw = driveViewUrl(driveId);

  // compute placement: below the node rectangle
  // For left->right layout: node is at (d.x, d.y), we place preview at (d.x, d.y + offset)
  // We want preview to appear below node visually (so y increases for rightwards), but we can place it slightly below (vertical)
  const px = d.x;
  const py = d.y + 24; // place to the right a little
  const imageW = IMAGE_WIDTH;
  const imageH = Math.floor(imageW * 0.66);

  // Append group
  const pg = g.append("g").attr("class", "img-preview-group");

  // compute top-left such that preview appears slightly below node center
  const x = px - imageW/2;     // center under node horizontally
  const y = py + 18;          // below the node rectangle vertically (since y is horizontal axis, we offset further right; but svg coords are x vertical, y horizontal)
  // Note: in our tree, coordinates are (x,y) => x vertical, y horizontal. For placing a box "below" the node visually when tree grows left->right,
  // we interpret "below" as slightly towards bottom of svg (increase x). So we add an x offset, while keeping y relatively near node's horizontal position.
  const boxX = x;
  const boxY = d.x + 28; // vertical offset downward
  const boxWidth = Math.min(imageW, 1200); // cap
  const boxHeight = imageH;

  // Use foreignObject so we can style image easily
  const fo = pg.append("foreignObject")
    .attr("x", boxX)
    .attr("y", boxY)
    .attr("width", boxWidth)
    .attr("height", boxHeight)
    .attr("class", "preview-fo");

  const foDiv = fo.append("xhtml:div")
    .attr("class", "preview-box")
    .style("width", boxWidth + "px")
    .style("height", boxHeight + "px")
    .style("display", "flex")
    .style("align-items", "center")
    .style("justify-content", "center")
    .style("padding", "6px")
    .style("box-sizing", "border-box");

  foDiv.append("img")
    .attr("src", raw)
    .attr("alt", d.data.Name || "")
    .attr("class", "img-preview")
    .style("width", "100%")
    .style("height", "auto")
    .on("click", (event) => {
      // collapse on click (A3-S1 behavior)
      event.stopPropagation();
      hidePreview();
    });

  // Optional details beneath image if present: add a small caption area
  if (d.data.Details) {
    // append a small caption as a separate foreignObject beneath the image
    const captionFo = pg.append("foreignObject")
      .attr("x", boxX)
      .attr("y", boxY + boxHeight + 6)
      .attr("width", boxWidth)
      .attr("height", 60);

    captionFo.append("xhtml:div")
      .style("font-size", "13px")
      .style("padding", "6px")
      .style("color", "#222")
      .style("background", "#fff")
      .style("border-radius", "4px")
      .style("box-shadow", "0 2px 8px rgba(0,0,0,0.08)")
      .html(d.data.Details);
  }

  openPreviewId = d.data.ID;
}

// clicking background hides preview
svg.on("click", () => {
  hidePreview();
});

// ESC to close
document.addEventListener("keydown", (ev) => {
  if (ev.key === "Escape") hidePreview();
});
</script>
</body>
</html>
