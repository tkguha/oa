<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>OA & OER</title>
	  <!-- Force HTTPS redirect -->
  <script>
    if (location.protocol !== 'https:') {
      location.replace(`https:${location.href.substring(location.protocol.length)}`);
    }
  </script>
	
  
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: "Segoe UI", Arial, sans-serif;
      background-color: #f8fafc;
      overflow: hidden;
    }

    header {
      background-color: #2196f3;
      color: white;
      text-align: center;
      padding: 15px 0;
      font-size: 24px;
      font-weight: 600;
      letter-spacing: 0.5px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
      position: relative;
      z-index: 2;
    }

    #info-box {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 300px;
      background: white;
      border: 1px solid #ccc;
      border-radius: 10px;
      padding: 12px 15px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      font-size: 14px;
      line-height: 1.5;
      color: #333;
      z-index: 3;
    }

    svg {
      width: 100%;
      height: calc(100vh - 70px);
      cursor: grab;
    }

    .link {
      fill: none;
      stroke: #bbb;
      stroke-width: 2px;
    }

    .node rect {
      fill: #e3f2fd;
      stroke: #2196f3;
      stroke-width: 2px;
      rx: 10;
      ry: 10;
      filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.2));
    }

    .node text {
      font-size: 15px;
      fill: #111;
    }
  </style>
</head>
<body>
  <header>Distortions in Open Access (OA) and impact on Open Educational Resources (OER)</header>

  <div id="info-box">
    <strong>About this presentation:</strong><br>
    this presentation has been prepared as part of KEDLE-2025 speech.<br>
    The model will remain active in public domain for few days.<br><br>
    Visitors are requested to the author to contact personally for a static graphics of this site
  </div>

  <svg></svg>

  <script>
    const csvUrl =
      "https://docs.google.com/spreadsheets/d/e/2PACX-1vQbYH3fZ0Fkz4Co5QtSCoZzkWku4jurdda6ttNrWKbJXG94odN5X0hSL06CfaHKREYJ7H8aa8PQmWOx/pub?output=csv";

    const svg = d3.select("svg");
    const g = svg.append("g");

    // Zoom & Pan
    const zoom = d3.zoom()
      .scaleExtent([0.3, 2.5])
      .on("zoom", (event) => g.attr("transform", event.transform));
    svg.call(zoom);

    const treeLayout = d3.tree().nodeSize([70, 250]);
    const duration = 600;

    d3.csv(csvUrl).then((data) => {
      const rootData = data.find((d) => !d.ParentID);
      function buildTree(node) {
        const children = data.filter((d) => d.ParentID === node.ID);
        if (children.length) node.children = children.map(buildTree);
        return node;
      }

      const root = d3.hierarchy(buildTree(rootData));
      root.x0 = 0;
      root.y0 = 0;
      root.children?.forEach(collapse);

      update(root);

      svg.call(
        zoom.transform,
        d3.zoomIdentity.translate(window.innerWidth / 2 - 100, 100).scale(0.8)
      );

      function collapse(d) {
        if (d.children) {
          d._children = d.children;
          d._children.forEach(collapse);
          d.children = null;
        }
      }

      function update(source) {
        const treeData = treeLayout(root);
        const nodes = treeData.descendants();
        const links = treeData.links();

        nodes.forEach((d) => (d.y = d.depth * 250));

        // --- NODES ---
        const node = g.selectAll("g.node").data(nodes, (d) => d.data.ID);

        const nodeEnter = node
          .enter()
          .append("g")
          .attr("class", "node")
          .attr("transform", (d) => `translate(${source.y0},${source.x0})`)
          .on("click", (event, d) => {
            if (d.children) {
              d._children = d.children;
              d.children = null;
            } else {
              d.children = d._children;
              d._children = null;
            }
            update(d);
          });

        // Append text first to measure width
        nodeEnter
          .append("text")
          .attr("dy", "0.35em")
          .attr("x", 0)
          .attr("text-anchor", "middle")
          .text((d) => d.data.Name);

        // After rendering, compute text size dynamically
        nodeEnter.each(function (d) {
          const textEl = d3.select(this).select("text").node();
          const bbox = textEl.getBBox();
          const paddingX = 12;
          const paddingY = 6;
          const rectWidth = bbox.width + paddingX * 2;
          const rectHeight = bbox.height + paddingY * 2;

          // Append rectangle *behind* text
          d3.select(this)
            .insert("rect", "text")
            .attr("x", -rectWidth / 2)
            .attr("y", -rectHeight / 2)
            .attr("width", rectWidth)
            .attr("height", rectHeight)
            .attr("rx", 10)
            .attr("ry", 10)
            .style("fill", "#e3f2fd")
            .style("stroke", "#2196f3")
            .style("stroke-width", 2);
        });

        // Update node positions
        const nodeUpdate = nodeEnter
          .merge(node)
          .transition()
          .duration(duration)
          .attr("transform", (d) => `translate(${d.y},${d.x})`);

        // Remove exiting nodes
        node.exit()
          .transition()
          .duration(duration)
          .attr("transform", (d) => `translate(${source.y},${source.x})`)
          .remove();

        // --- LINKS ---
        const link = g.selectAll("path.link").data(links, (d) => d.target.data.ID);

        const linkEnter = link
          .enter()
          .insert("path", "g")
          .attr("class", "link")
          .attr("d", (d) => {
            const o = { x: source.x0, y: source.y0 };
            return diagonal(o, o);
          });

        linkEnter
          .merge(link)
          .transition()
          .duration(duration)
          .attr("d", (d) => diagonal(d.source, d.target));

        link.exit().transition().duration(duration).remove();

        // Save old positions
        nodes.forEach((d) => {
          d.x0 = d.x;
          d.y0 = d.y;
        });
      }

      function diagonal(s, d) {
        return `M ${s.y} ${s.x}
                C ${(s.y + d.y) / 2} ${s.x},
                  ${(s.y + d.y) / 2} ${d.x},
                  ${d.y} ${d.x}`;
      }
    });
  </script>
</body>

</html>
